[{"path":"/articles/cons_and_values.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1 Introduction","title":"2) Estimating Consequences for Subsequent Analyses","text":"first vignette Get started, rules thumb used evaluate degree reliability. vignette, like demonstrate situation-specific evaluation reliability possible. , continue example first vignette, can find . focus kind analysis function get_consequences(), can used evaluate pretests coding schemes, well planning evaluating existing studies. cut-values judging reliability derived way ensures high data quality many practical situations. study Berding Pargmann (2022), demanding situations chosen. Thus, applications, rules thumb may strict. Additionally, may helpful understand consequences induced specific reliability values. illustrate kind analysis, need extend example introducing new variable. Let us assume participants exam interviewed order assess confident students abilities successfully pass exam. Let us assume degree confidence varies “low”, “medium” “high”. analogy studies investigating relationship achievement self-concept (Huang 2011; Möller et al. 2020), assume participants better exams higher confidence abilities. Figure 1 illustrates relationship. Figure 1: Assumed Relationship Performance Ability Self Concept prove relationship, use data exams rated interviews. Whether can draw right conclusions data depends reliability generated data, sample size sample method. can explored detail function get_consequences()","code":""},{"path":"/articles/cons_and_values.html","id":"using-get_consequences","dir":"Articles","previous_headings":"","what":"2 Using get_consequences()","title":"2) Estimating Consequences for Subsequent Analyses","text":"function get_consequences() provides information impact reliability significance testing drawing conclusions. requires least four arguments. measure_typ can decide measure reliability like use scale level. Currently, recommend use measure_typ = \"dynamic_iota_index\" analysis, measure showed highest value R² predicting different kinds data quality. measure_1_val can set reliability independent variable. example, performance participant shows exam. , value Dynamic Iota Index .267 (see Get started). measure_2_val can set reliability dependent variable. value set explicitly, analysis assumes reliability independent variable. example, dependent variable refers data interviews showing participants’ confidence abilities. Let us assume corresponding value Dynamic Iota Index .879. argument data_type sets scale level. Currently, “nominal” “ordinal” possible. case nominal data, results function refer significance tests Cramer’s V. case ordinal data, statistics refer significance tests Kendall’s Tau. example, scales form ordinal scale. argument strength closely connected data type refers true strength relationship independent dependent variable. argument can set “”, “weak”, “medium” “strong”. categories based work Cohen (1988), classified statistical measures according relevance real-world applications. Thus,“” imply value 0 Kendall’s Tau, small value around 0. “Strong” imply perfect relationship, rather refers values .5. Cohen’s (1988) work explicitly deal Kendall’s Tau instead employs Pearson correlation. Cramer’s V, situation complicated, class effect size depends number categories. However, considered function. example, assume medium relationship performance confidence. argument sample_size refers sample size planned already realized study. example, three raters judged written exams 318 participants analyzed corresponding interviews. Finally, level refers certainty level calculated prediction intervals. prediction interval characterizes probability true value within specific range around prediction (Afifi et al. 2020, p. 119). current example choose 95%. function calculates three important aspects investigating relationships. Deviation: first row called “deviation” characterizes expected deviation estimated sample effect size true sample effect size. Since using ordinal data, effect size Kendall’s Tau. mean value implies expect Kendall’s Tau differs error-free assessment .260 units. quite high use Cohen’s (1988) classification Pearson correlation. , meaning correlation changes every .20 units. upper lower values mean certainty 95%, estimated value Kendall’s Tau differs error-free estimation .107 .413 units. column “practically effect” reports probability effect size deviate .1 units. reliability .267 exams .879 interviews, chance 2%, low. last column, “practically weak effect”, reports probability Kendall’s Tau deviates less .3 units error-free measurement. probability 70%. first glance, seems high. However, probability implies nearly one third studies research design, values deviate .3 units. Classification rate: second row closely connected deviation. describes chance correctly classify effect size practically relevant, weak, medium strong, based Cohen’s (1988) classification. mean value implies chance correctly classify effect size .9%, low. upper lower values state certainty 95%, chance correctly classify effect size .2 2.8%. becomes clear current reliability .267 exams .879 interviews, risk drawing wrong conclusion strength relationship immense. column “practically effect” reports probability chance correctly classify effect size least 95%, last column reports probability correctly classify effect size least 90%. cases probability zero. Type errors: last row refers risk Type errors. Type errors mean context significance test implies acceptance null hypothesis, error-free measurement imply rejection null hypothesis. words: results significance test imply relationship, although error-free measurement imply acceptance relationship. mean value implies expect chance 21.5% Type error. , 21.5% cases, results significance tests imply relationship participants’ performance exam confidence abilities, although error-free measurement imply existence relationship. lower upper values imply certainty 95%, risk Type errors 6.4% 47.9%. Thus, high risk drawing wrong conclusions. column “practically effect” reports probability risk Type errors exceed 5% last column reports probability risk Type errors exceed 10%. current example, probability relevant effect 1.1 % weak effect 9.5%. Summing , information provided get_consequences() helps make suggested cut-values specific. information can used judge degree reliability situation-specifical manner can support planning evaluation studies.","code":"library(iotarelr) #> Loading required package: ggplot2 #> Warning: package 'ggplot2' was built under R version 4.1.3 #> Loading required package: ggalluvial #> Warning: package 'ggalluvial' was built under R version 4.1.3 get_consequences(measure_typ = \"dynamic_iota_index\",                  measure_1_val = .267,                  measure_2_val = .879,                  data_type = \"ordinal\",                  strength = \"medium\",                  sample_size=318,                  level = 0.95) #>                       lower 0.95 %  mean upper 0.95 % practically no effect #> deviation                    0.107 0.260        0.413                 0.020 #> classification rate          0.002 0.009        0.028                 0.000 #> risk of Type I errors        0.064 0.215        0.479                 0.011 #>                       practically weak effect #> deviation                               0.695 #> classification rate                     0.000 #> risk of Type I errors                   0.095"},{"path":"/articles/cons_and_values.html","id":"limitations","dir":"Articles","previous_headings":"","what":"3 Limitations","title":"2) Estimating Consequences for Subsequent Analyses","text":"important note analysis limitations. First, two types significance tests supported (Cramer’s V Kendall’s Tau). Second, analysis assumes independent dependent variables number categories. Thus, please use results orientation.","code":""},{"path":"/articles/cons_and_values.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"2) Estimating Consequences for Subsequent Analyses","text":"Afifi, ., May, S., Donatello, R. . & Clark, V. . (2020). Practical Multivariate Analysis (6th ed.). Chapman Hall/ CRC Texts Statistical Science Ser. CRC Press LLC. Huang, C. (2011). Self-concept academic achievement: meta-analysis longitudinal relations. Journal school psychology, 49(5), 505–528. https://doi.org/10.1016/j.jsp.2011.07.001 Cohen, J. (1988). Statistical Power Analysis Behavioral Sciences (2nd Ed.). Taylor & Francis. Möller, J., Zitzmann, S., Helm, F., Machts, N. & Wolff, F. (2020). Meta-Analysis Relations Achievement Self-Concept. Review Educational Research, 90(3), 376–419. https://doi.org/10.3102/0034654320919354","code":""},{"path":"/articles/dgf.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1 Introduction","title":"3) Different Guidance Functioning","text":"vignette, like show tools Iota Concept can used analyze suitability coding scheme rating different kinds materials. analysis similar analysis different item functioning (DIF) item-response theory. focal point question whether coding scheme degree reliability different groups materials. issue closely connected question coding scheme reproduces bias specific groups. coding scheme perceived measurement instrument, like test questionnaire, must reliable valid. Reliability validity demand absence different guidance functioning (DGF), since existence DGF means data influenced sources, example phenomenon interest. use term “different guidance functioning” order eliminate kind analysis DIF. Furthermore, like express coding scheme usually provides guideline raters assessing phenomenon. analysis DIF important broad range applications. example, ensuring ratings newspapers prefer discourage specific political parties. ensuring books different languages rated without influence different languages. ensuring social media contributions rated similarly without bias platform-specific form contribution. ensuring material created different groups learners assessed without bias socioeconomic background. … following, like illustrate kind analysis continuing example first vignette. order conduct analysis DGF, need additional data contains information different coding units grouped. Let us look sample data set.","code":""},{"path":[]},{"path":"/articles/dgf.html","id":"basic-analysis","dir":"Articles","previous_headings":"2 Example Analysis","what":"2.1 Basic Analysis","title":"3) Different Guidance Functioning","text":"data set contains ratings exams three raters additional column called “Sex”. column stores information participant exam identifies male female. Since exam measure participants’ performance fair, Assignment Error Matrix groups differ. , men women chance good, average poor exam. corresponding analysis can requested via function check_dgf(). function similar compute_iota2() additional argument, splitcr. argument uses group information analysis data uses ratings. Please note calling function may take time. results stored object dgf_exam. every group specified column “Sex”, model Iota2 fitted. results can accessed way objects created compute_iota2(). thing request function get_summary()results specific group. Let us start females. summary females shows basic information fitted model. best log-likelihood replicated. Thus, can confident model represents best model females. Special attention paid Assignment Error Matrix, since matrix describes true categories assigned. females, average exam recognized indeed average exam 88.7% cases. good exam recognized good exam 50% cases. remaining 50% cases assigned average exam poor exam probability 25%. truly poor exam assigned poor exam 50% cases average exam nearly cases. error assign poor exam good exam 5%. Let us now look results men. men, result different. According Assignment Error Matrix, average exam recognized average exam 50% cases. recognized average exam, higher chance considered good exam poor one. Concentrating good exams, Assignment Error Matrix shows probability categories. implies good exam assigned randomly three categories. poor exams high chance assigned correct category 70%. Comparing Assignment Error Matrices, becomes clear coding scheme reliable females men. different degrees reliability affect labeled data can explored function plot_iota(). can directly pass object dgf_exam function. Figure 1: Plot Iota different Groups Let us start average exams females. red rectangle category implies data labeled “average” contains lot exams truly either good poor exams (Iota Error II). red rectangle even bigger green (Iota) orange ones (Iota Error ), meaning number averagely good exams overestimated females. Concentrating males, red rectangle (Iota Error II) quite small orange one (Iota Error ) quite big. Thus, number averagely good exams underestimated. Regarding good exams females, red rectangle quite small (Iota Error II). means small number average poor exams labeled good. However, orange rectangle quite big (Iota Error ). nearly size green rectangle (Iota). Thus, data good exams misses half corresponding exams. means number good exams underestimated data set females. Concentrating males, Iota .18, low. Thus, good exams reliably represented individual data. contrast, 36% labeled data missing good exams (Iota Error ). Instead, data set made 46% exams categories (Iota Error II). , truly average truly poor exams. exams compensate missing good exams. consequence, average male participants, number good exams actually quite correct males. level single males, data reliable. Finally, diagrams poor exams look similar men women. women, number missing poor exams higher men (Iota Error ). contrast, data labeled poor exams contains exams truly belong category “good” “average” men well females (Iota Error II). Thus, average female participants, number poor exams quite correct well. males, number poor exams overestimated. men well women, data reliable individual level.","code":"library(iotarelr) #> Loading required package: ggplot2 #> Warning: package 'ggplot2' was built under R version 4.1.3 #> Loading required package: ggalluvial #> Warning: package 'ggalluvial' was built under R version 4.1.3 head(iotarelr_written_exams) #>   Coder A Coder B Coder C    Sex #> 1 average average    good female #> 2 average    poor average   male #> 3    poor average    poor female #> 4 average average average female #> 5    poor average    good female #> 6    poor    poor average female dgf_exam<-check_dgf(data=iotarelr_written_exams[c(\"Coder A\",\"Coder B\",\"Coder C\")],                     splitcr = iotarelr_written_exams$Sex,                     random_starts = 300) get_summary(dgf_exam$group_female) #> Summary #>  #> Call: compute_iota2 #>  #> Number of Raters: 3 #> Number of Categories: 3 #> Categories: average,good,poor #> Number of Coding Units: 173 #>  #> Random Start: 300 #> Log-Likelihood: 549.189068930457 #> The best log-likelihood has been replicated. #>  #> Primary Parameters #> Assignment Error Matrix #>         average  good  poor #> average   0.887 0.113 0.000 #> good      0.252 0.507 0.241 #> poor      0.441 0.052 0.507 #>  #> Categorical Sizes #> average    good    poor  #>   0.138   0.621   0.241  #>  #> Categorical Level #>           dimensions average   good   poor #> 1              Alpha  0.8869 0.5069 0.5066 #> 2               Beta   0.382 0.7897 0.5348 #> 3               Iota  0.3061 0.4848 0.3124 #> 4  Iota Error Type I   0.039 0.4716 0.3042 #> 5 Iota Error Type II  0.6549 0.0436 0.3833 #>  #> Scale Level #> Iota Index: 0.378 #> Static Iota Index: 0.078 #> Dynamic Iota Index: 0.329 get_summary(dgf_exam$group_male) #> Summary #>  #> Call: compute_iota2 #>  #> Number of Raters: 3 #> Number of Categories: 3 #> Categories: average,good,poor #> Number of Coding Units: 145 #>  #> Random Start: 300 #> Log-Likelihood: 461.506346602124 #> The best log-likelihood has not been replicated. Increase the #>       number of random stars and/or inspect the Assignment Error Matrices and #>       categorical sizes. #>  #> Primary Parameters #> Assignment Error Matrix #>         average  good  poor #> average   0.534 0.263 0.203 #> good      0.333 0.333 0.333 #> poor      0.085 0.161 0.755 #>  #> Categorical Sizes #> average    good    poor  #>   0.617   0.199   0.185  #>  #> Categorical Level #>           dimensions average   good   poor #> 1              Alpha  0.5336 0.3334 0.7547 #> 2               Beta  0.5394 0.4232 0.5442 #> 3               Iota  0.4711 0.1696 0.3705 #> 4  Iota Error Type I  0.4117  0.339 0.1204 #> 5 Iota Error Type II  0.1172 0.4914 0.5091 #>  #> Scale Level #> Iota Index: 0.302 #> Static Iota Index: 0.035 #> Dynamic Iota Index: 0.271 plot_iota(dgf_exam,           ylab = \"Groups\")"},{"path":"/articles/dgf.html","id":"coding-stream-analysis","dir":"Articles","previous_headings":"2 Example Analysis","what":"2.2 Coding Stream Analysis","title":"3) Different Guidance Functioning","text":"Since version 0.1.3, iotarelr provides additional analysis coding stream able make interpretation data convenient. kind analysis can request via function plot_iota2_alluvial(). Please note estimates passed directly function. results single group compatible. Applied current example, Figure 2 shows coding stream analysis females. interpretation plot explained vignette Get started. Figure 2: Stream Plot Females Comparing boxes true labeled data, becomes clear number average exams overestimated number good exams underestimated. sizes boxes true assigned poor exams similar. , average, number poor exams represented labeled date quite correctly. stream plot illustrates exams labeled good exams made exams truth good exams high extent. can seen big green curve blue red curves, comparison small. exams labeled poor exams made poor good exams 50%. data labeled average exams made exams truth good, average poor one third. Figure 3: Stream Plot Males Turning males, stream plot different. Comparing boxes true assigned categories, becomes clear number average exams underestimated poor exams overestimated. Furthermore, coding scheme leads small overestimation good exams. Thus, coding stream plot reflects results section 2.1, indicating coding scheme tends divide males’ exams good poor exams average , compared error-free measurement.","code":"plot_alluvial_females<-plot_iota2_alluvial(   dgf_exam$group_female,   label_titel = \"Coding Stream from True to Assigned Categories (Females)\") plot(plot_alluvial_females) plot_alluvial_males<-plot_iota2_alluvial(   dgf_exam$group_male,   label_titel = \"Coding Stream from True to Assigned Categories (Males)\") plot(plot_alluvial_males)"},{"path":"/articles/dgf.html","id":"summary","dir":"Articles","previous_headings":"","what":"3 Summary","title":"3) Different Guidance Functioning","text":"sum , coding scheme treats exams males females differently. number averagely good exams overestimated females underestimated men. number good exams underestimated females quite accurate men, although number source wrong exam categories. Finally, number poor exams quite correct females, although sources quite lot wrong exams, number poor exams men tends overestimated. Thus, descriptive statistics, females appear lower performance truly . men, data shows tendency show either good poor performance nothing . example shows guidance coding scheme can analyzed different groups materials. information can help developing coding schemes free bias, providing reliable valid source data subsequent analysis conclusions.","code":""},{"path":"/articles/doc/cons_and_values.html","id":"introduction","dir":"Articles > Doc","previous_headings":"","what":"1 Introduction","title":"2) Estimating Consequences for Subsequent Analyses","text":"first vignette Get started, rules thumbs used evaluate degree reliability. vignette, like demonstrate situation-specific evaluation reliability possible. , continue example first vignette, can find . center kind analysis function get_consequences() can used evaluate pretests coding schemes, well planning evaluating existing studies. cut-values judging reliability derived way ensures high data quality many practical situations. study Berding Pargmann (2022), demanding situations chosen. Thus, applications, rules thumb may strict. Additionally, may helpful understand consequences induced specific reliability values. illustrate kind analysis, need extent example introducing new variable. Let us assume participants exam interviewed order asses confident students abilities successfully pass exam. Let us assume degree confidence varies “low”, “medium” “high”. analogy studies investigating relationship achievement self-concept (Huang 2011; Möller et al. 2020), assume participants better exams higher confidence abilities. Figure 1 illustrates relationship. Figure 1: Assumed Relationship Performance Ability Self Concept prove relationship, use data exams rated interviews. Whether can draw right conclusions data depends reliability generated data, sample size sample method. can explored detail function get_consequences()","code":""},{"path":"/articles/doc/cons_and_values.html","id":"using-get_consequences","dir":"Articles > Doc","previous_headings":"","what":"2 Using get_consequences()","title":"2) Estimating Consequences for Subsequent Analyses","text":"function get_consequences() provides information impact reliability significance testing drawing conclusions. requires least four arguments. measure_typ can decide measure reliability like use scale level. Currently, recommend use measure_typ = \"dynamic_iota_index\" analysis, measure showed highest value R² predicting different kinds data quality. measure_1_val can set reliability independent variable. example, performance participant shows exam. , value Dynamic Iota Index .267 (see Get started). measure_2_val can set reliability dependent variable. value set explicitly, analysis assumes reliability independent variable. example, dependent variable refers data interviews showing participants’ confidence abilities. Let`s assume corresponding value Dynamic Iota Index .879. argument data_type sets scale level. Currently, “nominal” “ordinal” possible. case nominal data, results function refer significance tests Cramer’s V. case ordinal data, statistics refer significance tests Kendall’s Tau. example, scales form ordinal scale. argument strength closely connected data type refers true strength relationship independent dependent variable. argument can set “”, “weak”, “medium” “strong”. categories based work Cohen (1988), classified statistical measures according relevance real-world applications. Thus,“” imply value 0 Kendall’s Tau, small value around 0. “Strong” imply perfect relationship, rather refers values .5. Cohen’s (1988) work explicitly deal Kendall’s Tau instead employs Pearson correlation. Cramer’s V, situation complicated, class effect size depends number categories. However, considered function. example, assume medium relationship performance confidence. argument sample_size refers sample size planned already realized study. example, three raters judged written exams 318 participants analyzed corresponding interviews. Finally, level refers certainty level calculated prediction intervals. prediction interval characterizes probability true value within specific range around prediction (Afifi et al. 2020, p. 119). current example choose 95%. function calculates three important aspects investigating relationships. Deviation: first row called “deviation” characterizes expected deviation estimated sample effect size true sample effect size. Since using ordinal data, effect size Kendall’s Tau. mean value implies expect Kendall’s Tau differs error-free assessment .260 units. quite high use Cohen’s (1988) classification Pearson correlation. , meaning correlation changes every .20 units. values lower upper mean certainty 95%, estimated value Kendall’s Tau differs error-free estimation .107 .413 units. column “practically effect” reports probability effect size deviate .1 units. reliability .267 exams .879 interviews, chance 2 %, low. last column, “practically weak effect”, reports probability Kendall’s Tau deviates less .3 units error-free measurement. probability 70%. first glance, seems high. However, probability implies nearly one third studies research design, values deviate .3 units. Classification rate: second row closely connected deviation. describes chance correctly classify effect size practically relevant, weak, medium strong, based Cohens’s (1988) classification. mean value implies chance correctly classify effect size .9%, low. upper lower values state certainty 95%, chance correctly classify effect size .2 2.8%. becomes clear current reliability .267 exams .879 interviews, risk drawing wrong conclusion strength relationship immense. column “practically effect” reports probability chance correctly classify effect size least 95%, last column reports probability correctly classify effect size least 90%. cases probability zero. Type errors: last row refers risk Type errors. Type errors mean context significance test implies acceptance null hypothesis, error free measurement imply rejection null hypothesis. words: results significance test imply relationship, although error-free measurement imply acceptance relationship. mean value implies expect chance 21.5% Type error. , 21.5% cases, results significance tests imply relationship participants’ performance exam confidence abilities, although error-free measurement imply existence relationship. lower upper values imply certainty 95%, risk Type errors 6.4% 47.9%. Thus, high risk drawing wrong conclusions. column “practically effect” reports probability risk Type errors exceed 5 % last column reports probability risk Type errors exceed 10%. current example probability relevant effect 1.1 % weak effect 9.5%. Summing , information provided get_consequences() helps make suggested cut-values specific. information can used judge degree reliability situation-specific can support planning evaluating studies.","code":"library(iotarelr) get_consequences(measure_typ = \"dynamic_iota_index\",                  measure_1_val = .267,                  measure_2_val = .879,                  data_type = \"ordinal\",                  strength = \"medium\",                  sample_size=318,                  level = 0.95) #>                       lower 0.95 %  mean upper 0.95 % practically no effect #> deviation                    0.107 0.260        0.413                 0.020 #> classification rate          0.002 0.009        0.028                 0.000 #> risk of Type I errors        0.064 0.215        0.479                 0.011 #>                       practically weak effect #> deviation                               0.695 #> classification rate                     0.000 #> risk of Type I errors                   0.095"},{"path":"/articles/doc/cons_and_values.html","id":"limitations","dir":"Articles > Doc","previous_headings":"","what":"3 Limitations","title":"2) Estimating Consequences for Subsequent Analyses","text":"important note analysis limitations. First, two types significance tests supported (Cramer’s V Kendall’s Tau). Second, analysis assumes independent dependent variables number categories. Thus, please use results orientation.","code":""},{"path":"/articles/doc/cons_and_values.html","id":"references","dir":"Articles > Doc","previous_headings":"","what":"References","title":"2) Estimating Consequences for Subsequent Analyses","text":"Afifi, ., May, S., Donatello, R. . & Clark, V. . (2020). Practical Multivariate Analysis (6th ed.). Chapman Hall/ CRC Texts Statistical Science Ser. CRC Press LLC. Huang, C. (2011). Self-concept academic achievement: meta-analysis longitudinal relations. Journal school psychology, 49(5), 505–528. https://doi.org/10.1016/j.jsp.2011.07.001 Cohen, J. (1988). Statistical Power Analysis Behavioral Sciences (2nd Ed.). Taylor & Francis. Möller, J., Zitzmann, S., Helm, F., Machts, N. & Wolff, F. (2020). Meta-Analysis Relations Achievement Self-Concept. Review Educational Research, 90(3), 376–419. https://doi.org/10.3102/0034654320919354","code":""},{"path":"/articles/doc/dgf.html","id":"introduction","dir":"Articles > Doc","previous_headings":"","what":"1 Introduction","title":"3) Different Guidance Functioning","text":"vignette, like show tools Iota Concept can used analyze suitability coding scheme rating different kinds materials. analysis similar analysis different item functioning (DIF) item response theory. focal point question whether coding scheme degree reliability different groups materials. issue closely connected question coding scheme reproduces bias specific groups. coding scheme perceived measurement instrument, like test questionnaire, must reliable valid. Reliability validity demand absence different guidance functioning (DGF), since existence DGF means data influenced sources, example phenomenon interest. use term “different guidance functioning” order eliminate kind analysis DIF. Furthermore, like express coding scheme usually provides guideline raters assessing phenomenon. analysis DIF important broad range applications. example, ensuring ratings newspapers prefer discourage specific political parties. ensuring books different languages rated without influence different languages. ensuring social media contributions rated similarly without bias platform-specific form contribution. ensuring material created different groups learners assessed without bias socioeconomic background. … following, like illustrate kind analysis continuing example first vignette. order conduct analysis DGF, need additional data contains information different coding units grouped. Let us look sample data set.","code":""},{"path":"/articles/doc/dgf.html","id":"example-analysis","dir":"Articles > Doc","previous_headings":"","what":"2 Example Analysis","title":"3) Different Guidance Functioning","text":"data set contains ratings exams three raters additional column called “Sex”. column stores information participant exam identifies male female. Since exam measure participants’ performance fair, Assignment Error Matrix groups differ. , men women chance good, average poor exam. corresponding analysis can requested via function check_dgf(). function similar compute_iota2() additional argument, splitcr. argument uses group information analysis data uses ratings. Please note calling function may take time. results stored object dgf_exam. every group specified column “Sex” model Iota2 fitted. results accessed way objects created compute_iota2(). thing request function get_summary()results specific group. Let’s start females. summary females show basic information fitted model. best log-likelihood replicated. Thus, can confident model represents best model females. Special attention paid Assignment Error Matrix, since matrix describes true categories assigned. females, average exam assigned indeed average exam 88.7% cases. good exam assigned good exam 50% cases. remaining 50% cases assigned average exam poor exam probability 25%. truly poor exam assigned poor exam 50% cases nearly cases average exam. error assign poor exam good exam 5%. Let us now look results men. men, result different. According Assignment Error Matrix, average exam assigned average exam 54.4% cases. recognized average exam, higher chance considered good exam poor one. Concentrating good exams, Assignment Error Matrix shows probability categories. implies good exam assigned randomly three categories. poor exams high chance assigned correct category 75.1%. , poor exam assigned poor exam three four cases. Comparing Assignment Error Matrices, becomes clear coding scheme reliable females men. different degrees reliability affect labeled data can explored function plot_iota(). can directly pass object dgf_exam function. Figure 1: Plot Iota different Groups Let us start average exams females. red rectangle category implies data labeled “average” contains lot exams truly either good poor exams (Iota Error II). red rectangle even bigger green (Iota) orange ones (Iota Error ), meaning number averagely good exams overestimated females. Concentrating males, red rectangle (Iota Error II) quite small organ one (Iota Error ) quite big. Thus, number averagely good exams underestimated. Regarding good exams females, red rectangle quite small (Iota Error II). means small number average poor exams labeled good. However, orange rectangle quite big (Iota Error ). nearly size green rectangle (Iota). Thus, data good exams misses half corresponding exams. means number good exams underestimated data set females. Concentrating males, Iota .189, low. Thus, good exams reliably represented individual data. contrast, 37.7% labeled data missing good exams (Iota Error ). Instead, data set made 43.4% exams categories (Iota Error II). , truly average truly poor exams. exams compensate missing good exams. consequence, average male participants, number good exams actually quite correct males. level single males, data reliable. Finally, diagrams poor exams look similar men women. women, number missing poor exams higher men (Iota Error ). contrast, data labeled poor exams contains exams truly belong category “good” “average” men well females (Iota Error II). Thus, average female participants, number poor exams quite correct well. males, number poor exams overestimated. men well women, data reliable individual level.","code":"library(iotarelr) head(iotarelr_written_exams) #>   Coder A Coder B Coder C    Sex #> 1 average average    good female #> 2 average    poor average   male #> 3    poor average    poor female #> 4 average average average female #> 5    poor average    good female #> 6    poor    poor average female dgf_exam<-check_dgf(data=iotarelr_written_exams[c(\"Coder A\",\"Coder B\",\"Coder C\")],                     splitcr = iotarelr_written_exams$Sex,                      random_starts = 2) get_summary(dgf_exam$group_female) #> Summary #>  #> Call: compute_iota2 #>  #> Number of Raters: 3 #> Number of Categories: 3 #> Categories: average,good,poor #> Number of Coding Units: 173 #>  #> Random Start: 2 #> Log-Likelihood: 549.189068930579 #> The best log-likelihood has been replicated. #>  #> Primary Parameters #> Assignment Error Matrix #>         average  good  poor #> average   0.887 0.113 0.000 #> good      0.252 0.507 0.241 #> poor      0.441 0.052 0.507 #>  #> Categorical Sizes #> average    good    poor  #>   0.138   0.621   0.241  #>  #> Categorical Level #>           dimensions average   good   poor #> 1              Alpha  0.8869 0.5069 0.5066 #> 2               Beta   0.382 0.7897 0.5348 #> 3               Iota  0.3061 0.4848 0.3124 #> 4  Iota Error Type I   0.039 0.4716 0.3042 #> 5 Iota Error Type II  0.6549 0.0436 0.3833 #>  #> Scale Level #> Iota Index: 0.378 #> Static Iota Index: 0.078 #> Dynamic Iota Index: 0.329 get_summary(dgf_exam$group_male) #> Summary #>  #> Call: compute_iota2 #>  #> Number of Raters: 3 #> Number of Categories: 3 #> Categories: average,good,poor #> Number of Coding Units: 145 #>  #> Random Start: 2 #> Log-Likelihood: 461.504035085927 #> The best log-likelihood has not been replicated. Increase the #>       number of random stars and/or inspect the Assignment Error Matrices and #>       categorical sizes. #>  #> Primary Parameters #> Assignment Error Matrix #>         average  good  poor #> average   0.545 0.260 0.196 #> good      0.333 0.333 0.333 #> poor      0.089 0.159 0.752 #>  #> Categorical Sizes #> average    good    poor  #>   0.578   0.238   0.184  #>  #> Categorical Level #>           dimensions average   good   poor #> 1              Alpha  0.5448 0.3333 0.7518 #> 2               Beta  0.5317  0.419  0.544 #> 3               Iota  0.4675 0.1899 0.3679 #> 4  Iota Error Type I  0.3907 0.3797 0.1215 #> 5 Iota Error Type II  0.1418 0.4304 0.5106 #>  #> Scale Level #> Iota Index: 0.299 #> Static Iota Index: 0.035 #> Dynamic Iota Index: 0.268 plot_iota(dgf_exam,           ylab = \"Groups\")"},{"path":"/articles/doc/dgf.html","id":"summary","dir":"Articles > Doc","previous_headings":"","what":"3 Summary","title":"3) Different Guidance Functioning","text":"sum , coding scheme treats exams males females differently. number averagely good exams overestimated females underestimated men. number good exams underestimated females quite accurate men, although number source wrong exam categories. Finally, number poor exams quite correct females, although sources quite lot wrong exams, number poor exams men tends overestimated. Thus, descriptive statistics, females appear lower performance truly . men, data shows tendency show either good poor performance nothing . example shows guidance coding scheme can analyzed different groups materials. information can help developing coding schemes free bias, providing reliable valid source data subsequent analysis conclusion.","code":""},{"path":"/articles/doc/error_correction.html","id":"introduction","dir":"Articles > Doc","previous_headings":"","what":"1 Introduction","title":"4) Error Correction","text":"Literature regarding content analysis often presents estimation reliability part development phase coding scheme, example inform revision (Krippendorff, 2019; Kuckartz, 2018; Mayring, 2015; Schreier, 2012). reliability considered sufficient, main study starts. Often, reliability codings main study controlled, assumed reliability estimates development phase hold entire main study. Sometimes however, researchers communicate discuss findings assign category coding unit agreeing relevant category coding scheme unclear. Iota Concept, reliability coding scheme can taken account explicitly main study. provides opportunity error corrections, possible traditional measures Percentage Agreement, Cohen’s Kappa Krippendorff’s Alpha. error correction Iota Concept based two ideas. First, Assignment Error Matrix produces patterns ratings every coding unit. patterns give hints true category may source kind observation. requires least two raters. Second, involving additional raters provides information coding unit, can improve assignments. idea similar application multiple items questionnaires tests item can considered test phenomena interest. Additional test used reduce errors. vignette, like continue example exams example first vignette want show error correction can applied.","code":""},{"path":"/articles/doc/error_correction.html","id":"using-the-error-correction-of-the-iota-concept","dir":"Articles > Doc","previous_headings":"","what":"2 Using the error correction of the Iota Concept","title":"4) Error Correction","text":"Applying error correction Iota Concept requires coding units core study rated least two raters. error correction can requested function est_expected_categories(). function calculates probability coding unit belongs specific true category condition observed pattern. illustrate error correction, look data set helpful. first 6 rows data set show three raters agree coding units. raters agree first two exams, disagree partially exams 3 6. particular, two raters consider exam 3 average one rater considers exams good. Thus, seems kind error clear category assigned exam 3. solve problem, must first estimate Assignment Error Matrix. next step, pass estimated Assignment Error Matrix function est_expected_categories() use ratings data source. results saved object expected_categories. resulting object contains ratings additional columns. columns contain probability coding unit belongs specific true category. first two rows, probability exams truly poor ones 94.5%. chance exams represent truly good exams 5.5% truly average exams nearly 0%. exams number 3 4, probability average exam 48.2%, good exam 36.4% poor exam 15.2%. Thus, plausible assign exams number 3 4 category “average”. plausible category always presented last column. ratings done one rater, kind errors become visible. example, exams rated rater B, exams 3 4 assigned good exams, although plausible assign category “average”.","code":"library(iotarelr) head(iotarelr_written_exams) #>   Coder A Coder B Coder C    Sex #> 1 average average    good female #> 2 average    poor average   male #> 3    poor average    poor female #> 4 average average average female #> 5    poor average    good female #> 6    poor    poor average female res_iota2<-compute_iota2(   data=iotarelr_written_exams[c(\"Coder A\",\"Coder B\",\"Coder C\")],   random_starts = 2,   trace = FALSE) expected_categories<-est_expected_categories(   data=iotarelr_written_exams[c(\"Coder A\",\"Coder B\",\"Coder C\")],   aem=res_iota2$categorical_level$raw_estimates$assignment_error_matrix) head(expected_categories) #>   Coder A Coder B Coder C prob_average  prob_good  prob_poor expected_category #> 1 average average    good 4.842872e-01 0.36358524 0.15212757           average #> 2 average    poor average 1.297354e-06 0.27614114 0.72385756              poor #> 3    poor average    poor 1.278373e-13 0.12922012 0.87077988              poor #> 4 average average average 9.169917e-01 0.04109962 0.04190864           average #> 5    poor average    good 1.351292e-07 0.48178423 0.51821564              poor #> 6    poor    poor average 1.278373e-13 0.12922012 0.87077988              poor"},{"path":"/articles/doc/error_correction.html","id":"conclusions","dir":"Articles > Doc","previous_headings":"","what":"3 Conclusions","title":"4) Error Correction","text":"Estimating likely true category several advantages: allows multiple testing coding units two raters. additional information can used calculate certainty assignment. category likely true assigned coding unit. Errors made one rater can avoided. Researchers need discuss every coding unit, binds financial time resources large sample sizes.","code":""},{"path":"/articles/doc/error_correction.html","id":"references","dir":"Articles > Doc","previous_headings":"","what":"References","title":"4) Error Correction","text":"Früh, W. (2017). Inhaltsanalyse: Theorie und Praxis (9., überarbeitete Auflage). UTB. Krippendorff, K. (2019). Content Analysis: Introduction Methodology (4th Ed.). SAGE. Kuckartz, U. (2018). Qualitative Inhaltsanalyse: Methoden, Praxis, Computerunterstützung (4. Auflage). Grundlagentexte Methoden. Beltz. Mayring, P. (2015). Qualitative Inhaltsanalyse: Grundlagen und Techniken (12., überarbeitete Auflage). Beltz. Schreier, M. (2012). Qualitative Content Analysis Practice. SAGE.","code":""},{"path":"/articles/doc/iotarelr.html","id":"introduction","dir":"Articles > Doc","previous_headings":"","what":"1 Introduction","title":"Get started","text":"iotarelr package estimating components Iota Reliability Concept. first version concept described Berding et al. (2022). current version Iota2 (Berding & Pargmann 2022). vignette, describe use package basis current version. show calculate interpret basic components. Advanced analyses described separate vignettes can find via articles. order use iotarelr, need load package beginning analysis. introduction, use sample data set called “iotarelr_written_exams”. data set contain real data written exams. data set created illustrating purposes . Let us look . data set contains four columns. first three columns contain ratings three coders. , every written essay scored three people. terms content analysis, three raters judged every essay, representing coding units. essay can rated “poor”, “average” “good”. Thus, three categories available. fourth column contains gender person wrote essay. column, however, important moment. kinds data can used analyze codings work similarly across different groups people different groups materials. kind analysis described vignette Different Guidance Functioning. Keep mind moment, ignoring column. Iota Concept provides measures allow inspect reliability single categories well complete scale. different traditional measures reliability content analysis, Percentage Agreement, Cohen’s Kappa Krippendorff’s Alpha focus scale level . Since literature content analysis, terms “category”, “scale” “dimension” used differently, important understand Iota Concept uses terms. Figure 1 illustrates understanding. Figure 1: Scale Categories Iota Concept Regarding example, performance exams scale made three categories: “good”, “average” “poor”. Since categories can sorted degree performance, form ordinal scale. example nominal scale colors. , different colors categories. make scale “color”. important note Iota Concept differentiates two layers data, shown Figure 2. Figure 2: Layers Data within Iota Concept coding units units coding scheme applied. example, exams. exam true category. , exam good, average poor. categories make true data. However, true categories inherently known. Thus, raters use coding scheme decide category coding unit. example, raters judge exam good, average poor assign corresponding category coding unit/exam. assignments make labeled data. However, ensured assigned category true category. example, Figure 2, exam 1 assigned category “good”, also true category. Exam 2 also assigned category “good”, although truth, exam represents average exam. Alike applies exam 3. assigned category true category match, certain. Since assigned category true category may differ, labeled data can vary degree well reflects true data. , degree overlapping true data labeled data can vary. Figure 2, three exams assigned good exams. Thus, data set contains three cases labeled good exams. Although cases labeled good, one case really good exam. Thus, true data labeled data category “good” overlap 33%. category “average”, true data labeled data overlap 0% since one exam truth average exam. However, labeled data representing . Something similar applies category “poor”. aim reliability ensure labeled data matches true data well possible. achieve aim, Iota Concept models coding process provides measures quantifying degree reliability shown following sections.","code":"library(iotarelr) head(iotarelr_written_exams) #>   Coder A Coder B Coder C    Sex #> 1 average average    good female #> 2 average    poor average   male #> 3    poor average    poor female #> 4 average average average female #> 5    poor average    good female #> 6    poor    poor average female"},{"path":[]},{"path":"/articles/doc/iotarelr.html","id":"estimation","dir":"Articles > Doc","previous_headings":"2 Example for using the Iota Concept of the second generation","what":"2.1 Estimation","title":"Get started","text":"calculation components Iota2 can requested using compute_iota2(). stage, crucial use part data set contains codings. every case, coding units rows raters columns. first save codings new object, request estimation Iota2 save results. estimation components Iota2 can take moment. like see progression, can set trace = TRUE. estimation finished, can request summary function get_summary(). summary first shows basic information number raters, number categories,concrete categories number coding units. Next, summary presents log-likelihood extent describes quality model. Lower values imply better fitting model higher values. Additionally, summary prints whether best log-likelihood replicated. case, recommend increase number random starts /investigate solutions ensure subsequent analyses based best model possible .","code":"codings<-iotarelr_written_exams[c(\"Coder A\",\"Coder B\",\"Coder C\")] res_iota2<-compute_iota2(data=codings,                          random_starts = 5,                          trace = FALSE) get_summary(res_iota2) #> Summary #>  #> Call: compute_iota2 #>  #> Number of Raters: 3 #> Number of Categories: 3 #> Categories: average,good,poor #> Number of Coding Units: 318 #>  #> Random Start: 5 #> Log-Likelihood: 1020.63294056504 #> The best log-likelihood has been replicated. #>  #> Primary Parameters #> Assignment Error Matrix #>         average  good  poor #> average   0.917 0.083 0.000 #> good      0.326 0.493 0.181 #> poor      0.328 0.204 0.468 #>  #> Categorical Sizes #> average    good    poor  #>   0.119   0.396   0.485  #>  #> Categorical Level #>           dimensions average   good   poor #> 1              Alpha  0.9171 0.4933 0.4684 #> 2               Beta  0.3718  0.594 0.6596 #> 3               Iota  0.2685  0.387 0.4081 #> 4  Iota Error Type I  0.0243 0.3976 0.4632 #> 5 Iota Error Type II  0.7073 0.2153 0.1288 #>  #> Scale Level #> Iota Index: 0.298 #> Static Iota Index: 0.074 #> Dynamic Iota Index: 0.267"},{"path":"/articles/doc/iotarelr.html","id":"analysing-the-reliability-on-the-categorical-level","dir":"Articles > Doc","previous_headings":"2 Example for using the Iota Concept of the second generation","what":"2.2 Analysing the reliability on the categorical level","title":"Get started","text":"Next, summary shows results primary parameters. Assignment Error Matrix categorical sizes, basis measures Iota Concept. Assignment Error Matrix describes rating process. true category always rows assigned categories always columns. current example, first row describes exams representing average performance assigned three different categories. exam representing average performance assigned exam 91.7 cases. 8.3% cases, average exam assigned good exam. Finally, average exam never assigned poor exam. , corresponding probability 0%. concentrating exams reflect good performance, second row Assignment Error Matrix important. 49.3% cases, good exam assigned good exam. words: probability recognize good exam good exam equals flipping coin. 32.6% cases, good exam assigned category “average”. , exam judged showing average performance, although truly good exam. Finally, good exam rated “poor” exam 18.1% cases. Thus, raters make mistakes evaluating good exam evaluating average exam (49.3% good exams compared 91.7% average exams). categorical sizes represent estimate distribution true categories population. example, expect 11.9% exams average, 39.6% good 48.5% poor. Based Assignment Error Matrix categorical sizes, additional measures reliability can derived. shown next lines summary. first Alpha Reliability, correspondents diagonal Assignment Error Matrix. determines probability coding unit specific category correctly assigned category. example, coding unit truly belonging category “average” assigned category “average” 91.71% cases. words: exam truly representing average performance rated average exam 91.71% cases. value quite high. contrast, Alpha Reliability category “good” .4933. means coding unit truly belonging category “good” assigned “good” 50% cases. quite bad result. Alike applies category “poor”. next row presents Beta Reliability, representing probability errors categories influence category investigation. example, Beta Reliability category “average” .3718. means rater makes mistake categories “good” “poor”, mistake assigned category “average” probability 37.18%. words: rater judge exam truly represents good poor performance rater recognize good poor performance, assign exam category “average” probability 37.18% . Focusing category “poor”, Beta Reliability .6596. means: rater judge exam truly reflects average good performance rater recognize good average performance, assign exam poor 65.96 % cases. Thus, Beta Reliability can used show errors categories influence data generated specific category. higher values, less influenced data category. example, category “average” influenced errors categories categories “good” “poor”. Finally, Iota Reliability combines Alpha Beta Reliability taking sizes categories account. Iota Reliability core Iota Concept. Iota Reliability measure describes well data labeled specific category really reflects category. considers three cases: cases assigned correct category (Iota) cases category recovered (Iota Error ) cases assigned category although truly belong another category (Iota Error II). start interpret values case example, additional explanations necessary. Figure 3 illustrates three cases. Figure 3: Illustrating Iota Referring first row Figure 3, box represents coding units truly belong category . case perfect reliability, labeled data corresponds coding units. Row two Figure 3 splits coding units category. green part box represents coding units, truth belong category part labeled data. yellow part box represents number coding units truth belong category , assigned category . coding units missing labeled data. situation presented row two, total number coding units representing category underestimated labeled data. Let us now turn third row provide complete view. labeled data category can also include coding units truly belong categories. coding units represented red box. results coding errors made categories increase number units labeled category , although truth, belong category . Thus, units contribute overestimation number coding units truly belong category . Iota refers green box row 3, Iota Error refers yellow box Iota Error II refers red box. three measures expressed ratio \\(N+n_{Iota Error II}\\). mind, can now interpret Iota Reliability. easiest way visualizing values. can done function plot_iota(). Figure 4: Example Plot Iota Category average: Let’s start category “average”. category, Iota .268. means 26.8% relevant labeled data really average exams. remaining 73.2% represent average exams missing results (Iota Error ) represent exams truly belong categories (Iota Error II). help plot, cases can characterized detail. yellow rectangle represents average exams part labeled data. number .024 indicates exams “forgotten”. red rectangle describes amount exams part labeled data average exams, truth good poor exams. made 70% labeled data. sum , data representing average exams recovers exams really average exams (Iota). ignores small amount exams really average exams (Iota Error ). extremely biased exams truth good poor (Iota Error II). amount greater Iota Iota Error combined, indicating number coding units average exams extremely overestimated labeled data compared true data. Thus, although category “average” quite reliable, low reliability categories destroys high quality part data represent average exams. Category good: Turning category “good”, Iota .387, implying 38.7% data labeled “good exams” really good exams. However, nearly number good exams represented data, yellow rectangle plot shows. Thus, half good exams missing labeled data. \\(\\frac{.398}{.387+.398}=.507\\). value .215, 21.5% data made exams truly represent average poor performance. Thus, data labeled “good exams” consists 39 % exams truth good exams (Iota). ignores 50 % exams truth good exams (Iota Error ). weakly biased exams truth average poor exams (Iota Error II). contrast data representing average exams, data representing good exams extremely biased categories, ignores high number relevant ones. Thus, labeled data underestimates number truly good exams compared true data. Category poor: Finally, let’s look category “poor”. , Iota .408, implying relevant data consist 40.8% correct coding units/exams. However, Iota Error .463, implying high number truly poor exams represented within labeled data category. Iota Error II .129 quite low, implying 12.9% relevant data made coding units truly representing good average exams. Thus, data representing poor exams consists exams truth poor exams 40.8% (Iota). ignores 53.2% exams truth poor exams (Iota Error ). weakly biased exams truth good average exams (Iota Error II). number poor exams underestimated labeled data compared true data. Summary: sum , sample coding scheme guiding ratings exams requires revision. data generated coding scheme heavily biased favor average exams. number average exams overestimated since lot good poor exams treated average exams. consequence, number good poor exams underestimated. Since Alpha Reliability category “average” quite high, revision focus categories “good” “poor”. revision aim provide precise definitions clearer suitable examples support raters perceiving true categories exams.","code":"plot_iota(res_iota2)"},{"path":"/articles/doc/iotarelr.html","id":"analysing-the-reliability-on-the-scale-level","dir":"Articles > Doc","previous_headings":"2 Example for using the Iota Concept of the second generation","what":"2.3 Analysing the reliability on the scale level","title":"Get started","text":"many cases, reliability singles categories important also reliability complete scale. Iota Concept provides several measures characterizing kind reliability. Currently, recommend use Dynamic Iota Index. measure ranges 0 1, 0 indicating absence reliability, 1 indicating perfect reliability. Referring summary , Dynamic Iota Index .267. low value replicates analysis categorical level. According rules thumb developed Berding Pargmann (2022), value sufficient generate reliable data. value least .829 allow subsequent statistical analysis correlation analysis significance testing. due fact degree reliability leads high deviations true sample correlation suffers high risk drawing wrong conclusions statistical analyses.","code":""},{"path":"/articles/doc/iotarelr.html","id":"further-readings","dir":"Articles > Doc","previous_headings":"","what":"3 Further readings","title":"Get started","text":"vignette, presented basic usage Iota Concept. like lean consequences reliability scale level, like recommend vignette Estimating Consequences Subsequent Analysis. interested Iota Concept can used analyze coding scheme performs similarly different group materials, recommend vignette Different Guidance Functioning. permanently working improving Iota Concept, please check package’s website news. details, like refer following literature: Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. Berding, Florian, Elisabeth Riebenbauer, Simone Stuetz, Heike Jahncke, Andreas Slopinski, Karin Rebmann. 2022. Performance Configuration Artificial Intelligence Educational Settings.Introducing New Reliability Concept Based Content Analysis. Frontiers Education. https://doi.org/10.3389/feduc.2022.818365","code":""},{"path":"/articles/doc/new_rater.html","id":"introduction","dir":"Articles > Doc","previous_headings":"","what":"1 Introduction","title":"5) Training New Raters","text":"Many scientific studies include development new coding scheme study typically focus introductory literature content analysis (Krippendorff, 2019; Kuckartz, 2018; Mayring, 2015; Schreier, 2012). cases, reliability can estimated analyzed described first vignette. contrast literature new coding schemes, less recommendations refer application existing coding schemes available published studies sources. cases, necessary develop new scheme, rather apply existing one new data, often along new raters. application existing coding scheme new data several reasons. First, studies using coding scheme can directly compared, contributing knowledge accumulation specific topic discipline. Second, applying existing coding schemes provides opportunity prove results prior studies trying reproduce . Third, using existing scheme saves resources, since ideally, improvement cycle developing necessary. saves capacities become available important study characteristics (greater sample sizes, refining specific categories, considering categories etc.). Estimating reliability codings based existing coding scheme differs estimating reliability development coding scheme. phase developing coding scheme aims provide theoretically empirically sound guide data analysis. includes researchers raters clear interpretation categories data develop understanding categories based theory empircal evidence. Ideally, final coding scheme precise enough document shared understanding guide users interpretation data assignments data categories. contrast, phase applying existing coding scheme new raters aim incorporate interpretation data categories new raters. aim train new raters achieve understanding data categories documented scheme. existing coding scheme represents already discussed validated understanding, new raters acquire order apply coding scheme way development study preliminary study. consequence, reliability estimation consider existence predefined understanding.","code":""},{"path":"/articles/doc/new_rater.html","id":"estimating-the-quality-of-ratings-for-a-new-rater","dir":"Articles > Doc","previous_headings":"","what":"2 Estimating the quality of ratings for a new rater","title":"5) Training New Raters","text":"Within frame work Iota Concept, realized function check_new_rater(). order estimate well new rater developed understanding documented coding scheme, data material existing sources must used. new rater assigns material categories assignments compared existing assignments material. Based data, Assignment Error Matrix new rater can calculated. illustrate process, continue example first vignette. First, simulate “old” study calculating Iota2 example. Second, calculate likely true category coding unit. assignments serve us “true” categories. practice, steps performed every case. old source provides final assignments coding units, values can used “true” values. Third, new rater rate material old source. , new rater rate exams coding scheme. results saved vector iotarelr_new_rater. Now, can request reliability estimate rater requesting function check_new_rater(). resulting object class iotarelr_iota2. Thus, can use function get_summary() look results. Focusing Assignment Error Matrix, values diagonal high. leads high vales Alpha Reliability, 78.73% average exams, 85.90% good exams 93.24% poor exams. Thus, chance high new rater assign correct categories. Please note interpretation values now slightly different development phase. , high values indicate new rater high chance assign categories coding unit old study. also documented values Iota range .6735 average exams .8334 poor exams. Dynamic Iota Index quite high .716. Finally, can plot results new rater. Figure 1: Plot Iota New Rater plot Iota new rater emphasizes able recover large number true categories kinds exams. case average exams, coding units belonging category part labeled data. , nearly number forgotten average exams compensated coding units categories. Thus, average, number coding units labeled data average exams equals true number, individual level errors.","code":"library(iotarelr) res_iota2<-compute_iota2(data=iotarelr_written_exams[c(\"Coder A\",\"Coder B\",\"Coder C\")],                          random_starts = 2,                          trace = FALSE) expected_categories<-est_expected_categories(   data=iotarelr_written_exams[c(\"Coder A\",\"Coder B\",\"Coder C\")],   aem=res_iota2$categorical_level$raw_estimates$assignment_error_matrix) true_values<-expected_categories$expected_category res_new_rater<-check_new_rater(   true_values = true_values,   assigned_values = iotarelr_new_rater) get_summary(res_new_rater) #> Summary #>  #> Call: check_new_rater #>  #> Number of Raters: 1 #> Number of Categories: 3 #> Categories: average,good,poor #> Number of Coding Units: 318 #>  #> Random Start: NA #> Log-Likelihood: NA #>  #>  #> Primary Parameters #> Assignment Error Matrix #>         average  good  poor #> average   0.357 0.286 0.357 #> good      0.205 0.397 0.397 #> poor      0.313 0.178 0.509 #>  #> Categorical Sizes #> average    good    poor  #>   0.242   0.245   0.513  #>  #> Categorical Level #>           dimensions average   good   poor #> 1              Alpha  0.3571 0.3974 0.5092 #> 2               Beta  0.4725 0.6062 0.3938 #> 3               Iota   0.191 0.2403 0.3747 #> 4  Iota Error Type I  0.3438 0.3643 0.3612 #> 5 Iota Error Type II  0.4653 0.3954 0.2641 #>  #> Scale Level #> Iota Index: 0.2 #> Static Iota Index: 0.004 #> Dynamic Iota Index: 0.187 plot_iota(res_new_rater)"},{"path":"/articles/doc/new_rater.html","id":"conclusion","dir":"Articles > Doc","previous_headings":"","what":"3 Conclusion","title":"5) Training New Raters","text":"function check_new_rater() provides detailed insights new rater acquired understanding existing coding scheme. information can used individually guide training process new raters, since Assignment Error Matrix Iota Reliability provide hints errors occur everything fine. can increase quality codings saves costs time, making replication comparison studies using content analysis easy.","code":""},{"path":"/articles/doc/new_rater.html","id":"references","dir":"Articles > Doc","previous_headings":"","what":"References","title":"5) Training New Raters","text":"Früh, W. (2017). Inhaltsanalyse: Theorie und Praxis (9., überarbeitete Auflage). UTB. Krippendorff, K. (2019). Content Analysis: Introduction Methodology (4th Ed.). SAGE. Kuckartz, U. (2018). Qualitative Inhaltsanalyse: Methoden, Praxis, Computerunterstützung (4. Auflage). Grundlagentexte Methoden. Beltz. Mayring, P. (2015). Qualitative Inhaltsanalyse: Grundlagen und Techniken (12., überarbeitete Auflage). Beltz. Schreier, M. (2012). Qualitative Content Analysis Practice. SAGE.","code":""},{"path":"/articles/doc/vig_Iota_1.html","id":"important-note","dir":"Articles > Doc","previous_headings":"","what":"Important Note","title":"How to use Iota1","text":"Please note Iota1 outdated. Please use new version Iota2. Central definitions Iota changed new version. Please refer Get startet vignette updated future developments.","code":""},{"path":"/articles/doc/vig_Iota_1.html","id":"introduction","dir":"Articles > Doc","previous_headings":"","what":"1 Introduction","title":"How to use Iota1","text":"Reliability central characteristic assessment instrument, describes extent instrument produces error-free data (Schreier, 2012). terms content analysis, Krippendorff (2019) suggests replicability fundamental reliability concept, also referred inter-coder reliability. describes degree “process can reproduced different analysts, working varying conditions, different locations, using different functionally equivalent measuring instruments” (Krippendorff, 2019). package iotarelr provides environment estimating degree inter-coder reliability based Iota Reliability Concept developed Berding et al. (2022). concept provides one first measures characterizing degree reliability complete scale every single category. older measures limited information complete scale. suggested concept applicable kind content analysis uses coding scheme nominal ordinal data regardless kind coders (human artificial intelligence), number coders, number categories. following introduction shows use Iota1.","code":""},{"path":[]},{"path":"/articles/doc/vig_Iota_1.html","id":"estimating-the-values","dir":"Articles > Doc","previous_headings":"2 Example for using iotarelr in practice","what":"2.1 Estimating the values","title":"How to use Iota1","text":"beginning, data generated least two coders needed. Let us assume four coders analyzed 20 textual fragments coding scheme consisting three categories , B, C. example, characteristics saved characters. package also supports categories stored integers. important aspect rows must contain coding units (e.g., textual fragments), columns represent different coders. next step, estimation iota elements starts via function compute_iota1().","code":"library(iotarelr) coder_1<-c(\"A\",\"A\",\"C\",\"C\",\"B\",\"A\",\"A\",\"B\",\"C\",\"A\",\"B\",\"C\",\"A\",\"B\",\"A\",\"B\",\"C\",\"A\",\"A\",\"C\") coder_2<-c(\"A\",\"A\",\"C\",\"B\",\"B\",\"A\",\"A\",\"B\",\"C\",\"A\",\"A\",\"C\",\"A\",\"C\",\"A\",\"B\",\"A\",\"A\",\"A\",\"C\") coder_3<-c(\"A\",\"A\",\"C\",\"C\",\"B\",\"A\",\"A\",\"B\",\"C\",\"A\",\"B\",\"C\",\"A\",\"B\",\"A\",\"B\",\"C\",\"A\",\"A\",\"C\") coder_4<-c(\"A\",\"C\",\"C\",\"C\",\"B\",\"A\",\"A\",\"B\",\"C\",\"A\",\"B\",\"A\",\"A\",\"B\",\"A\",\"C\",\"B\",\"A\",\"A\",\"C\")  coded_data<-cbind(coder_1,coder_2,coder_3,coder_4) results<-compute_iota1(data=coded_data)"},{"path":"/articles/doc/vig_Iota_1.html","id":"the-alpha-values","dir":"Articles > Doc","previous_headings":"2 Example for using iotarelr in practice","what":"2.2 The alpha values","title":"How to use Iota1","text":"component $alpha saves values chance-corrected alpha reliabilities. values describe extend true characteristic coding unit discovered. ranges 0 1. 0 indicates absence reliability. , assignment true category equals random selection categories. 1 indicates true value always recovered. current example, chance-corrected alpha value category relatively high. means coding scheme leads coders assign characteristic coding unit true characteristic coding unit high probability. contrast, values two categories low. indicates coding unit true characteristic B C often assigned categories. , coding scheme ensure coders discover true category true category B C.","code":"results$alpha #>              A        B         C #> [1,] 0.5647321 0.140625 0.2020089"},{"path":"/articles/doc/vig_Iota_1.html","id":"the-beta-values","dir":"Articles > Doc","previous_headings":"2 Example for using iotarelr in practice","what":"2.3 The beta values","title":"How to use Iota1","text":"provide detailed insight coding scheme, beta values account errors occur case true category discovered. , beta values describe extent category influenced errors made categories. example, true category coding unit coder assign coding unit, data category B C biased. data representing categories B C comprises coding unit part data. chance-corrected values beta reliabilites stored $beta range 0 1. 0 indicates beta reliability equals beta reliability case complete guessing. 1 indicate absence beta errors. current example, chance-corrected beta reliabilities relatively high. means different categories strongly influenced errors categories.","code":"results$beta #>             A         B         C #> [1,] 0.746875 0.6835938 0.6203125"},{"path":"/articles/doc/vig_Iota_1.html","id":"the-iota-values","dir":"Articles > Doc","previous_headings":"2 Example for using iotarelr in practice","what":"2.4 The iota values","title":"How to use Iota1","text":"Iota values summarize different types errors category averaging chance-corrected reliabilities. stored $iota. Iota can range 0 1. 0 indicates quality coding category equals random guessing. Codings category reliable. 1 indicates perfect reliability category. , true value coding unit recovered true category category investigation errors made coding coding units categories note influence data category investigation. current example category quite reliable categories .","code":"results$iota #>              A         B         C #> [1,] 0.6558036 0.4121094 0.4111607"},{"path":"/articles/doc/vig_Iota_1.html","id":"assignment-error-matrix-aem","dir":"Articles > Doc","previous_headings":"2 Example for using iotarelr in practice","what":"2.5 Assignment-Error Matrix (AEM)","title":"How to use Iota1","text":"assignment-error matrix combines alpha beta values provides detailed description coding scheme. based raw estimates without chance-correction. AEM read row row rows represent true category coding unit columns represent assigned categories. values diagonal represent alpha-error categories. probability assign true category coding unit. cells describe probability assign category categories. , inform probability choose category condition true category recovered. example, alpha-error category .43 meaning coding unit category coded another category 43 %. words: probability assign true category coding unit category 57%. Thus, second third cell first row mean: true category coding unit belonging category recovered, 45% codings assigned category B 55% codings assigned category C. Thus, category C suffers errors made coding units truly belonging category category B. alpha-error category B .85. Thus 85% cases coding units truly belonging category B assigned another category. words: probability recover true category 15 % true category coding unit B. case error occurs, 40% cases assigned category 60 % assigned category C. Thus, data category C suffers errors made coding units belonging truly category B category . alpha-error category C 79%. Thus, 79% cases coding unit truly belonging category C assigned category B. error occurs 44 % codings units treated category 56% treated category B. consequence, category B suffers form errors made codings units category C category . words: data category B strongly biased errors category C data category .","code":"results$assignment_error_matrix #>           A         B         C #> A 0.4285714 0.4545455 0.5454545 #> B 0.4000000 0.8461538 0.6000000 #> C 0.4444444 0.5555556 0.7857143"},{"path":"/articles/doc/vig_Iota_1.html","id":"scale-level","dir":"Articles > Doc","previous_headings":"2 Example for using iotarelr in practice","what":"2.6 Scale level","title":"How to use Iota1","text":"measures described provide detailed insights reliability every single category new feature content analysis helpful constructing coding scheme evaluating data empirical studies. many applications however, values summarized values representing quality complete coding scheme. Iota Concept done averaging iota values category. value accessible $average_iota. current example average iota .49. moment rule thumb ordinal data exist. According Berding et al. (2022) average iota least .474 necessary acceptable level reliability scale level. “good” reliability average iota least .601.","code":"results$average_iota #> [1] 0.4930246"},{"path":"/articles/doc/vig_Iota_1.html","id":"references","dir":"Articles > Doc","previous_headings":"","what":"References","title":"How to use Iota1","text":"Berding, F., Elisabeth r., Simone S., Jahncke, H., Slopinski, ., Rebmann, K. (2022). Performance Configuration Artificial Intelligence Educational Settings. Introducing New Reliability Concept Based Content Analysis. Frontiers Education. https://doi.org/10.3389/feduc.2022.818365 Krippendorff, K. (2019). Content Analysis: Introduction Methodology Schreier, M. (2012). Qualitative Content Analysis Practice. SAGE.","code":""},{"path":"/articles/error_correction.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1 Introduction","title":"4) Error Correction","text":"Literature regarding content analysis often presents estimation reliability part development phase coding scheme, example inform revision (Krippendorff, 2019; Kuckartz, 2018; Mayring, 2015; Schreier, 2012). reliability considered sufficient, main study starts. Often, reliability codings main study controlled, assumed reliability estimates development phase hold entire main study. Sometimes however, researchers communicate discuss findings assign category coding unit agreeing relevant category coding scheme unclear. Iota Concept, reliability coding scheme can taken account explicitly main study. provides opportunity error corrections, possible traditional measures Percentage Agreement, Cohen’s Kappa Krippendorff’s Alpha. error correction Iota Concept based two ideas. First, Assignment Error Matrix produces patterns ratings every coding unit. patterns give hints true category may source kind observation. requires least two raters. Second, involving additional raters provides information coding unit, can improve assignments. idea similar application multiple items questionnaires tests item can considered test phenomena interest. Additional test used reduce errors. vignette, like continue example exams first vignette now want show error correction can applied.","code":""},{"path":"/articles/error_correction.html","id":"using-the-error-correction-of-the-iota-concept","dir":"Articles","previous_headings":"","what":"2 Using the error correction of the Iota Concept","title":"4) Error Correction","text":"Applying error correction Iota Concept requires coding units core study rated least two raters. error correction can requested function est_expected_categories(). function calculates probability coding unit belongs specific true category condition observed pattern. illustrate error correction, look data set helpful. first 6 rows data set show three raters agree coding units. raters agree first two exams, disagree partially exams 3 6. particular, two raters consider exam 3 average one rater considers exams good. Thus, seems kind error clear category assigned exam 3. solve problem, must first estimate Assignment Error Matrix. next step, pass estimated Assignment Error Matrix function est_expected_categories() use ratings data source. results saved object expected_categories. resulting object contains ratings additional columns. columns contain probability coding unit belongs specific true category. plausible category always presented last column. first row, probability exam truly average one 48.4%. chance exam represents truly good exam 36.3% truly poor exam 15.2%. Thus, plausible assign exam number 1 category “average”. exam number two, probability exam truly average one 0.00%. chance exam represents truly good exam 27.6% truly poor exam 72.4%. Thus, plausible assign exam number 2 category “poor”. ratings done one rater, kind errors become visible. example, exams rated rater , exam 2 assigned average exam, although plausible assign category “poor”.","code":"library(iotarelr) #> Loading required package: ggplot2 #> Warning: package 'ggplot2' was built under R version 4.1.3 #> Loading required package: ggalluvial #> Warning: package 'ggalluvial' was built under R version 4.1.3 head(iotarelr_written_exams) #>   Coder A Coder B Coder C    Sex #> 1 average average    good female #> 2 average    poor average   male #> 3    poor average    poor female #> 4 average average average female #> 5    poor average    good female #> 6    poor    poor average female res_iota2<-compute_iota2(   data=iotarelr_written_exams[c(\"Coder A\",\"Coder B\",\"Coder C\")],   random_starts = 10,   trace = FALSE) expected_categories<-est_expected_categories(   data=iotarelr_written_exams[c(\"Coder A\",\"Coder B\",\"Coder C\")],   aem=res_iota2$categorical_level$raw_estimates$assignment_error_matrix) head(expected_categories) #>   Coder A Coder B Coder C prob_average  prob_good  prob_poor expected_category #> 1 average average    good 4.842782e-01 0.36360439 0.15211741           average #> 2 average    poor average 6.373066e-07 0.27617420 0.72382516              poor #> 3    poor average    poor 3.084868e-14 0.12924473 0.87075527              poor #> 4 average average average 9.169923e-01 0.04110162 0.04190605           average #> 5    poor average    good 6.637675e-08 0.48182762 0.51817232              poor #> 6    poor    poor average 3.084868e-14 0.12924473 0.87075527              poor"},{"path":"/articles/error_correction.html","id":"conclusions","dir":"Articles","previous_headings":"","what":"3 Conclusions","title":"4) Error Correction","text":"Estimating category likely true several advantages: allows multiple testing coding units two raters. additional information can used calculate certainty assignment. category likely true assigned coding unit. Errors made one rater can avoided. Researchers need discuss every coding unit, binds financial time resources large sample sizes.","code":""},{"path":"/articles/error_correction.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"4) Error Correction","text":"Früh, W. (2017). Inhaltsanalyse: Theorie und Praxis (9., überarbeitete Auflage). UTB. Krippendorff, K. (2019). Content Analysis: Introduction Methodology (4th Ed.). SAGE. Kuckartz, U. (2018). Qualitative Inhaltsanalyse: Methoden, Praxis, Computerunterstützung (4. Auflage). Grundlagentexte Methoden. Beltz. Mayring, P. (2015). Qualitative Inhaltsanalyse: Grundlagen und Techniken (12., überarbeitete Auflage). Beltz. Schreier, M. (2012). Qualitative Content Analysis Practice. SAGE.","code":""},{"path":"/articles/iotarelr.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1 Introduction","title":"Get started","text":"iotarelr package estimating components Iota Reliability Concept. first version concept described Berding et al. (2022). current version Iota2 (Berding & Pargmann 2022). vignette, describe use package basis current version. show calculate interpret basic components. Advanced analyses described separate vignettes can find via articles. order use iotarelr, need load package beginning analysis. introduction, use sample data set called “iotarelr_written_exams”. data set contain real data written exams. data set created illustration purposes . Let us look . data set contains four columns. first three columns contain ratings three coders. , every written essay scored three people. terms content analysis, three raters judged every essay, representing coding units. essay can rated “poor”, “average” “good”. Thus, three categories available. fourth column contains gender person wrote essay. column, however, important moment. kinds data can used analyze codings work similarly across different groups people different groups materials. kind analysis described vignette Different Guidance Functioning. Keep mind moment, ignoring column. Iota Concept provides measures allow inspect reliability single categories well complete scale. different traditional measures reliability content analysis, Percentage Agreement, Cohen’s Kappa Krippendorff’s Alpha focus scale level . Since literature content analysis, terms “category”, “scale” “dimension” used differently, important understand Iota Concept uses terms. Figure 1 illustrates understanding. Figure 1: Scale Categories Iota Concept Regarding example, performance exams scale made three categories: “good”, “average” “poor”. Since categories can sorted degree performance, form ordinal scale. example nominal scale colors. , different colors categories. make scale “color”. important note Iota Concept differentiates two layers data, shown Figure 2. Figure 2: Layers Data within Iota Concept coding units units coding scheme applied. example, exams. exam true category. , exam good, average poor. categories make true data. However, true categories inherently known. Thus, raters use coding scheme decide category coding unit. example, raters judge exam good, average poor assign corresponding category coding unit/exam. assignments make labeled data. However, ensured assigned category true category. example, Figure 2, exam 1 assigned category “good”, also true category. Exam 2 also assigned category “good”, although truth, exam represents average exam. Alike applies exam 3. assigned category true category match, certain. Since assigned category true category may differ, labeled data can vary degree well reflects true data. , degree overlapping true data labeled data can vary. Figure 2, three exams assigned good exams. Thus, data set contains three cases labeled good exams. Although cases labeled good, one case really good exam. Thus, true data labeled data category “good” overlap 33%. category “average”, true data labeled data overlap 0% since one exam truth average exam. However, labeled data representing . Something similar applies category “poor”. aim reliability ensure labeled data matches true data well possible. achieve aim, Iota Concept models coding process provides measures quantifying degree reliability shown following sections.","code":"library(iotarelr) #> Loading required package: ggplot2 #> Warning: package 'ggplot2' was built under R version 4.1.3 #> Loading required package: ggalluvial #> Warning: package 'ggalluvial' was built under R version 4.1.3 head(iotarelr_written_exams) #>   Coder A Coder B Coder C    Sex #> 1 average average    good female #> 2 average    poor average   male #> 3    poor average    poor female #> 4 average average average female #> 5    poor average    good female #> 6    poor    poor average female"},{"path":[]},{"path":"/articles/iotarelr.html","id":"estimation","dir":"Articles","previous_headings":"2 Example for using the Iota Concept of the second generation","what":"2.1 Estimation","title":"Get started","text":"calculation components Iota2 can requested using compute_iota2(). stage, crucial use part data set contains codings. every case, coding units rows raters columns. first save codings new object, request estimation Iota2 save results. estimation components Iota2 can take moment. like see progression, can set trace = TRUE. estimation finished, can request summary function get_summary(). summary first shows basic information number raters, number categories, concrete categories number coding units. Next, summary presents log-likelihood extent describes quality model. Lower values imply better fitting model higher values. Additionally, summary prints whether best log-likelihood replicated. case, recommend increase number random starts /investigate solutions ensure subsequent analyses based best model possible .","code":"codings<-iotarelr_written_exams[c(\"Coder A\",\"Coder B\",\"Coder C\")] res_iota2<-compute_iota2(data=codings,                          random_starts = 10,                          trace = FALSE) get_summary(res_iota2) #> Summary #>  #> Call: compute_iota2 #>  #> Number of Raters: 3 #> Number of Categories: 3 #> Categories: average,good,poor #> Number of Coding Units: 318 #>  #> Random Start: 10 #> Log-Likelihood: 1020.63294056467 #> The best log-likelihood has been replicated. #>  #> Primary Parameters #> Assignment Error Matrix #>         average  good  poor #> average   0.917 0.083 0.000 #> good      0.326 0.493 0.181 #> poor      0.328 0.204 0.468 #>  #> Categorical Sizes #> average    good    poor  #>   0.119   0.396   0.485  #>  #> Categorical Level #>           dimensions average   good   poor #> 1              Alpha  0.9171 0.4933 0.4684 #> 2               Beta  0.3718  0.594 0.6596 #> 3               Iota  0.2684 0.3872  0.408 #> 4  Iota Error Type I  0.0243 0.3977 0.4631 #> 5 Iota Error Type II  0.7073 0.2151 0.1289 #>  #> Scale Level #> Iota Index: 0.298 #> Static Iota Index: 0.074 #> Dynamic Iota Index: 0.267"},{"path":[]},{"path":"/articles/iotarelr.html","id":"interpretation-of-the-central-components","dir":"Articles","previous_headings":"2 Example for using the Iota Concept of the second generation > 2.2 Analysing the reliability on the categorical level","what":"2.2.1 Interpretation of the central components","title":"Get started","text":"Next, summary shows results primary parameters. Assignment Error Matrix categorical sizes, basis measures Iota Concept. Assignment Error Matrix describes rating process. true category always rows assigned categories always columns. current example, first row describes exams representing average performance assigned three different categories. exam representing average performance assigned exam 91.7% cases. 8.3% cases, average exam assigned good exam. Finally, average exam never assigned poor exam. , corresponding probability 0%. concentrating exams reflect good performance, second row Assignment Error Matrix important. 49.3% cases, good exam assigned good exam. words: probability recognize good exam good exam equals flipping coin. 32.6% cases, good exam assigned category “average”. , exam judged showing average performance, although truly good exam. Finally, good exam rated “poor” exam 18.1% cases. Thus, raters make mistakes evaluating good exam average exam (49.3% good exams compared 91.7% average exams). categorical sizes represent estimate distribution true categories population. example, expect 11.9% exams average, 39.6% good 48.5% poor. Based Assignment Error Matrix categorical sizes, additional measures reliability can derived. shown next lines summary. first Alpha Reliability, corresponds diagonal Assignment Error Matrix. determines probability coding unit specific category correctly assigned category. example, coding unit truly belonging category “average” assigned category “average” 91.71% cases. words: exam truly representing average performance rated average exam 91.71% cases. value quite high. contrast, Alpha Reliability category “good” .4933. means coding unit truly belonging category “good” assigned “good” 50% cases. quite bad result. Alike applies category “poor”. next row presents Beta Reliability, representing probability errors categories influence category investigation. example, Beta Reliability category “average” .3718. means rater makes mistake categories “good” “poor”, mistake assigned category “average” probability 37.18%. words: rater judge exam truly represents good poor performance rater recognize good poor performance, assign exam category “average” probability 37.18% . Focusing category “poor”, Beta Reliability .6596. means: rater judge exam truly reflects average good performance rater recognize good average performance, assign exam poor 65.96 % cases. Thus, Beta Reliability can used show errors categories influence data generated specific category. higher values, less influenced data category. example, category “average” influenced errors categories categories “good” “poor”. Finally, Iota Reliability combines Alpha Beta Reliability taking sizes categories account. Iota Reliability core Iota Concept. Iota Reliability measure describes well data labeled specific category really reflects category. considers three cases: cases assigned correct category (Iota) cases category recovered (Iota Error ) cases assigned category although truly belong another category (Iota Error II). start interpret values case example, additional explanations necessary. Figure 3 illustrates three cases. Figure 3: Illustrating Iota Referring first row Figure 3, box represents coding units truly belong category . case perfect reliability, labeled data corresponds coding units. Row two Figure 3 splits coding units category. green part box represents coding units truth belong category part labeled data. yellow part box represents number coding units truth belong category , assigned category . coding units missing labeled data. situation presented row two, total number coding units representing category underestimated labeled data. Let us now turn third row provide complete view. labeled data category can also include coding units truly belong categories. coding units represented red box. results coding errors made categories increase number units labeled category , although truth, belong category . Thus, units contribute overestimation number coding units truly belonging category . Iota refers green box row 3, Iota Error refers yellow box Iota Error II refers red box. three measures expressed ratio \\(N+n_{Iota Error II}\\). mind, can now interpret Iota Reliability. easiest way visualizing values. can done function plot_iota(). Figure 4: Example Plot Iota Category average: Let us start category “average”. category, Iota .268. means 26.8% relevant labeled data really average exams. remaining 73.2% represent average exams missing results (Iota Error ) represent exams truly belong categories (Iota Error II). help plot, cases can characterized detail. yellow rectangle represents average exams part labeled data. number .024 indicates exams “forgotten”. red rectangle describes amount exams part labeled data average exams, truth good poor exams. make 70% labeled data. sum , data representing average exams recovers exams really average exams (Iota). ignores small amount exams really average exams (Iota Error ). extremely biased exams truth good poor (Iota Error II). amount greater Iota Iota Error combined, indicating number coding units average exams extremely overestimated labeled data compared true data. Thus, although category “average” quite reliable, low reliability categories destroys high quality part data represent average exams. Category good: Turning category “good”, Iota .387, implying 38.7% data labeled “good exams” really good exams. However, nearly number good exams represented data, yellow rectangle plot shows. Thus, half good exams missing labeled data. \\(\\frac{.398}{.387+.398}=.507\\). value .215, 21.5% data made exams truly represent average poor performance. Thus, data labeled “good exams” consists exams truth good exams 39% (Iota). ignores 50 % exams truth good exams (Iota Error ). weakly biased exams truth average poor exams (Iota Error II). contrast data representing average exams, data representing good exams extremely biased categories, ignores high number relevant ones. Thus, labeled data underestimates number truly good exams compared true data. Category poor: Finally, let’s look category “poor”. , Iota .408, implying relevant data consist 40.8% correct coding units/exams. However, Iota Error .463, implying high number truly poor exams represented within labeled data category. Iota Error II .129 quite low, implying 12.9% relevant data made coding units truly representing good average exams. Thus, data representing poor exams consists 40.8% exams truth poor exams (Iota). ignores 53.2% exams truth poor exams (Iota Error ). weakly biased exams truth good average exams (Iota Error II). number poor exams underestimated labeled data compared true data. Summary: sum , sample coding scheme guiding ratings exams requires revision. data generated coding scheme heavily biased favor average exams. number average exams overestimated since lot good poor exams treated average exams. consequence, number good poor exams underestimated. Since Alpha Reliability category “average” quite high, revision focus categories “good” “poor”. revision aim provide precise definitions clearer suitable examples support raters perceiving true categories exams.","code":"plot_iota(res_iota2)"},{"path":"/articles/iotarelr.html","id":"coding-stream-analysis","dir":"Articles","previous_headings":"2 Example for using the Iota Concept of the second generation > 2.2 Analysing the reliability on the categorical level","what":"2.2.2 Coding Stream Analysis","title":"Get started","text":"Since version 0.1.3, ioatrelr provides additional analysis possibility via function plot_iota2_alluvial(). function takes estimated object Iota2 returns plot representing coding process guided coding scheme. current example, plot shown Figure 5. Figure 5: Alluvial Plot Iota2 boxes left side represent true categories distributed population. height directly reflects estimated true categorical sizes. boxes right side show amounts labeled data. curves two pairs boxes illustrate coding process. Average exams: Concentrating true average exams, plot illustrates true average exams part labeled data. can seen big red curve ranging true average exams labeled average exams. small number true average exams assigned good exams. can seen small red curve ranging true average exams good exams. Thus, true average exams correctly assigned. However, box labeled average exams several times larger box true average exams. indicates coding scheme tends overestimate number average exams. Figure 5 illustrates source overestimation truly good truly poor exams. can seen big green curve ranging truly good exams labeled average exams big blue curve ranging truly poor exams labeled average exams. Good exams: similar analysis possible good exams. three green curves ranging truly good exams categories illustrate truly good exams assigned different possible categories. two big curves show truly good exams assigned categories “good” “average”. smaller green curve indicates smaller number truly good exams assigned category poor exams. box truly good exams smaller box labeled good exams indicating labeled data underestimates number good exams. coding units behind labeled data good exams made mostly truly good exams (big green curve) followed high number truly poor exams (big blue curve) small number truly average exams (red curve). Poor exams: Finally, box labeled poor exams 0.5 times smaller box truly poor exams, indicating total number poor exams underestimated coding scheme. three blue curves illustrate truly poor exams assigned category “poor” labeled data. similar number truly poor exams assigned category “average” smaller number assigned category “good”. Summing , alluvial plot Iota2 provides additional insights coding scheme works illustrating coding stream splitting Iota, Iota Error Iota Error II detail.can helpful judging quality data reviewing coding scheme.","code":"plot_alluvial<-plot_iota2_alluvial(res_iota2) plot(plot_alluvial)"},{"path":"/articles/iotarelr.html","id":"analysing-the-reliability-on-the-scale-level","dir":"Articles","previous_headings":"2 Example for using the Iota Concept of the second generation","what":"2.3 Analysing the reliability on the scale level","title":"Get started","text":"many cases, reliability singles categories important also reliability complete scale. Iota Concept provides several measures characterizing kind reliability. Currently, recommend use Dynamic Iota Index. measure ranges 0 1, 0 indicating absence reliability, 1 indicating perfect reliability. Referring summary , Dynamic Iota Index .267. low value replicates analysis categorical level. According rules thumb developed Berding Pargmann (2022), value sufficient generate reliable data. value least .829 allow subsequent statistical analysis correlation analysis significance testing. due fact degree reliability leads high deviations true sample correlation suffers high risk drawing wrong conclusions statistical analyses.","code":""},{"path":"/articles/iotarelr.html","id":"further-readings","dir":"Articles","previous_headings":"","what":"3 Further readings","title":"Get started","text":"vignette, presented basic usage Iota Concept. like lean consequences reliability scale level, like recommend vignette Estimating Consequences Subsequent Analysis. interested Iota Concept can used analyze coding scheme performs similarly different group materials, recommend vignette Different Guidance Functioning. permanently working improving Iota Concept, please check package’s website news. details, like refer following literature: Florian Berding Julia Pargmann (2022). Iota Reliability Concept Second Generation. Measures Content Analysis Done Humans Artificial Intelligence. Berlin: Logos. https://doi.org/10.30819/5581 Florian Berding, Elisabeth Riebenbauer, Simone Stuetz, Heike Jahncke, Andreas Slopinski, Karin Rebmann (2022). Performance Configuration Artificial Intelligence Educational Settings. Introducing New Reliability Concept Based Content Analysis. Frontiers Education. https://doi.org/10.3389/feduc.2022.818365","code":""},{"path":"/articles/new_rater.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1 Introduction","title":"5) Test New Raters","text":"Many scientific studies include development new coding scheme study typically focus introductory literature content analysis (Krippendorff, 2019; Kuckartz, 2018; Mayring, 2015; Schreier, 2012). cases, reliability can estimated analyzed described first vignette. contrast literature new coding schemes, less recommendations refer application existing coding schemes, available published studies sources. cases, necessary develop new scheme, rather apply existing one new data, often along new raters. application existing coding scheme new data several reasons. First, studies using coding scheme can directly compared, contributing knowledge accumulation specific topic discipline. Second, applying existing coding schemes provides opportunity prove results prior studies trying reproduce . Third, using existing scheme saves resources, since ideally, improvement cycle developing necessary. saves capacities become available important study characteristics (greater sample sizes, refining specific categories, considering categories, etc.). Estimating reliability codings based existing coding scheme differs estimating reliability development coding scheme. phase developing coding scheme aims provide theoretically empirically sound guide data analysis. includes researchers raters clear interpretation categories data develop understanding categories based theory empirical evidence. Ideally, final coding scheme precise enough document shared understanding guide users interpretation data assignments data categories. contrast, phase applying existing coding scheme new raters aim incorporate interpretation data categories new raters. aim train new raters achieve understanding data categories documented scheme. existing coding scheme represents already discussed validated understanding, new raters acquire order apply coding scheme way development study preliminary study. consequence, reliability estimation consider existence predefined understanding.","code":""},{"path":"/articles/new_rater.html","id":"estimating-the-quality-of-ratings-for-a-new-rater","dir":"Articles","previous_headings":"","what":"2 Estimating the quality of ratings for a new rater","title":"5) Test New Raters","text":"Within framework Iota Concept, realized function check_new_rater(). order estimate well new rater developed understanding documented coding scheme, data material existing sources must used. new rater assigns material categories assignments compared existing assignments material. Based data, Assignment Error Matrix new rater can calculated. illustrate process, continue example first vignette. First, simulate “old” study calculating Iota2 example. Second, calculate likely true category coding unit. assignments serve us “true” categories. practice, steps performed every case. old source provides final assignments coding units, values can used “true” values. Third, new rater rate material old source. , new rater rate exams coding scheme. results saved vector iotarelr_new_rater. Now, can request reliability estimate rater requesting function check_new_rater(). resulting object class iotarelr_iota2. Thus, can use function get_summary() look results. Focusing Assignment Error Matrix, values diagonal low. leads low vales Alpha Reliability, 38.04% average exams, 41.67% good exams 50.92% poor exams. Thus, chance high new rater assign false categories. Please note interpretation values now slightly different development phase. , high values indicate new rater high chance assign different categories coding unit assigned old study. also documented values Iota, range .2078 average exams .3692 poor exams. Dynamic Iota Index quite low .213 Finally, can plot results new rater. Figure 1: Plot Iota New Rater plot Iota new rater emphasizes able recover small number true categories kinds exams. Additionally can also plot corresponding coding stream new rater. Figure 2: Stream Plot boxes left side represent true categories distributed population. height directly reflects true categorical sizes. boxes right side show amounts labeled data. curves two pairs boxes illustrate coding process. Average exams: Focusing true average exams, plot illustrates approximately one third truly average exams labeled average. represented big red stream going true average labeled average. rest exams truly average falsely labeled either poor good exams. shown curves going true average respectively labeled category (good poor). exams really average identified . alluvial plot, box true average exams slightly smaller ones labeled average. means coding scheme tends overestimate number average exams. false interpretations mostly stem true poor category labeled average, shown big blue curve going ‘labeled average’. contrast, small portion truly good exams incorrectly labeled average, demonstrated rather small green curve going true good labeled average. Good exams: Looking good exams, minority truly good exams labeled correctly. shown green curve going left (true good exams) right (labeled good). truly good exams labeled poor, quite big difference. size boxes “true good” exams “labeled good” exams similar, however latter almost entirely made wrong exams. means category seems right size, truly represented correctly lot truly poor truly average exams falsely labeled good. can seen bigger blue smaller red curve going box right side. sense, coding scheme estimates number good exams almost correctly slight tendency overestimate. Poor exams: Regarding poor exams, labeled poor exams box little bit smaller one true poor exams. composition boxes different, however. half truly poor exams labeled correctly, represented big blue bar going left right. remainder truly poor exams either labeled good average. falsely labeled truly poor exams labeled average (bigger blue curve) labeled good (smaller blue curve). Regarding “labeled poor” exams right, box made truly poor exams approximately 50%, remainder coming truly good (green curve) average (red curve) exams. means half exams truly poor also recognized poor. box left (true poor) right (labeled poor) similar size, although right one slightly smaller. means total number poor exams estimated quite correct slight tendency underestimate.","code":"library(iotarelr) #> Loading required package: ggplot2 #> Warning: package 'ggplot2' was built under R version 4.1.3 #> Loading required package: ggalluvial #> Warning: package 'ggalluvial' was built under R version 4.1.3 res_iota2<-compute_iota2(data=iotarelr_written_exams[c(\"Coder A\",\"Coder B\",\"Coder C\")],                          random_starts = 2,                          trace = FALSE) expected_categories<-est_expected_categories(   data=iotarelr_written_exams[c(\"Coder A\",\"Coder B\",\"Coder C\")],   aem=res_iota2$categorical_level$raw_estimates$assignment_error_matrix) true_values<-expected_categories$expected_category res_new_rater<-check_new_rater(   true_values = true_values,   assigned_values = iotarelr_new_rater) get_summary(res_new_rater) #> Summary #>  #> Call: check_new_rater #>  #> Number of Raters: 1 #> Number of Categories: 3 #> Categories: average,good,poor #> Number of Coding Units: 318 #>  #> Random Start: NA #> Log-Likelihood: NA #>  #>  #> Primary Parameters #> Assignment Error Matrix #>         average  good  poor #> average   0.380 0.239 0.380 #> good      0.167 0.417 0.417 #> poor      0.313 0.178 0.509 #>  #> Categorical Sizes #> average    good    poor  #>   0.242   0.245   0.513  #>  #> Categorical Level #>           dimensions average   good   poor #> 1              Alpha  0.3804 0.4167 0.5092 #> 2               Beta    0.49 0.6287  0.337 #> 3               Iota  0.2078 0.2591 0.3692 #> 4  Iota Error Type I  0.3383 0.3628 0.3559 #> 5 Iota Error Type II  0.4539 0.3781 0.2749 #>  #> Scale Level #> Iota Index: 0.231 #> Static Iota Index: 0.005 #> Dynamic Iota Index: 0.213 plot_iota(res_new_rater) plot_alluvial_new_rater<-plot_iota2_alluvial(res_new_rater) plot(plot_alluvial_new_rater)"},{"path":"/articles/new_rater.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"3 Conclusion","title":"5) Test New Raters","text":"function check_new_rater() provides detailed insights new rater acquired understanding existing coding scheme. information can used individually guide training process new raters, since Assignment Error Matrix Iota Reliability provide hints errors occur everything fine. can increase quality codings saves costs time, making replication comparison studies using content analysis easier.","code":""},{"path":"/articles/new_rater.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"5) Test New Raters","text":"Früh, W. (2017). Inhaltsanalyse: Theorie und Praxis (9., überarbeitete Auflage). UTB. Krippendorff, K. (2019). Content Analysis: Introduction Methodology (4th Ed.). SAGE. Kuckartz, U. (2018). Qualitative Inhaltsanalyse: Methoden, Praxis, Computerunterstützung (4. Auflage). Grundlagentexte Methoden. Beltz. Mayring, P. (2015). Qualitative Inhaltsanalyse: Grundlagen und Techniken (12., überarbeitete Auflage). Beltz. Schreier, M. (2012). Qualitative Content Analysis Practice. SAGE.","code":""},{"path":"/articles/vig_Iota_1.html","id":"important-note","dir":"Articles","previous_headings":"","what":"Important Note","title":"Old 1) How to use Iota1","text":"Please note Iota1 outdated. Please use new version Iota2. Central definitions Iota changed new version. Please refer Get started vignette updated future developments.","code":""},{"path":"/articles/vig_Iota_1.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1 Introduction","title":"Old 1) How to use Iota1","text":"Reliability central characteristic assessment instrument, describes extent instrument produces error-free data (Schreier, 2012). terms content analysis, Krippendorff (2019) suggests replicability fundamental reliability concept, also referred inter-coder reliability. describes degree “process can reproduced different analysts, working varying conditions, different locations, using different functionally equivalent measuring instruments” (Krippendorff, 2019). package iotarelr provides environment estimating degree inter-coder reliability based Iota Reliability Concept developed Berding et al. (2022). concept provides one first measures characterizing degree reliability complete scale every single category. older measures limited information complete scale. suggested concept applicable kind content analysis uses coding scheme nominal ordinal data regardless kind coders (human artificial intelligence), number coders, number categories. following introduction shows use Iota1.","code":""},{"path":[]},{"path":"/articles/vig_Iota_1.html","id":"estimating-the-values","dir":"Articles","previous_headings":"2 Example for using iotarelr in practice","what":"2.1 Estimating the values","title":"Old 1) How to use Iota1","text":"beginning, data generated least two coders needed. Let us assume four coders analyzed 20 textual fragments coding scheme consisting three categories , B, C. example, characteristics saved characters. package also supports categories stored integers. important aspect rows must contain coding units (e.g., textual fragments), columns represent different coders. next step, estimation iota elements starts via function compute_iota1().","code":"library(iotarelr) #> Loading required package: ggplot2 #> Warning: package 'ggplot2' was built under R version 4.1.3 #> Loading required package: ggalluvial #> Warning: package 'ggalluvial' was built under R version 4.1.3 coder_1<-c(\"A\",\"A\",\"C\",\"C\",\"B\",\"A\",\"A\",\"B\",\"C\",\"A\",\"B\",\"C\",\"A\",\"B\",\"A\",\"B\",\"C\",\"A\",\"A\",\"C\") coder_2<-c(\"A\",\"A\",\"C\",\"B\",\"B\",\"A\",\"A\",\"B\",\"C\",\"A\",\"A\",\"C\",\"A\",\"C\",\"A\",\"B\",\"A\",\"A\",\"A\",\"C\") coder_3<-c(\"A\",\"A\",\"C\",\"C\",\"B\",\"A\",\"A\",\"B\",\"C\",\"A\",\"B\",\"C\",\"A\",\"B\",\"A\",\"B\",\"C\",\"A\",\"A\",\"C\") coder_4<-c(\"A\",\"C\",\"C\",\"C\",\"B\",\"A\",\"A\",\"B\",\"C\",\"A\",\"B\",\"A\",\"A\",\"B\",\"A\",\"C\",\"B\",\"A\",\"A\",\"C\")  coded_data<-cbind(coder_1,coder_2,coder_3,coder_4) results<-compute_iota1(data=coded_data)"},{"path":"/articles/vig_Iota_1.html","id":"the-alpha-values","dir":"Articles","previous_headings":"2 Example for using iotarelr in practice","what":"2.2 The alpha values","title":"Old 1) How to use Iota1","text":"component $alpha saves values chance-corrected alpha reliabilities. values describe extend true characteristic coding unit discovered. ranges 0 1. 0 indicates absence reliability. , assignment true category equals random selection categories. 1 indicates true value always recovered. current example, chance-corrected alpha value category relatively high. means coding scheme leads coders assign characteristic coding unit true characteristic coding unit high probability. contrast, values two categories low. indicates coding unit true characteristic B C often assigned categories. , coding scheme ensure coders discover true category true category B C.","code":"results$alpha #>              A        B         C #> [1,] 0.5647321 0.140625 0.2020089"},{"path":"/articles/vig_Iota_1.html","id":"the-beta-values","dir":"Articles","previous_headings":"2 Example for using iotarelr in practice","what":"2.3 The beta values","title":"Old 1) How to use Iota1","text":"provide detailed insight coding scheme, beta values account errors occur case true category discovered. , beta values describe extent category influenced errors made categories. example, true category coding unit coder assign coding unit, data category B C biased. data representing categories B C comprises coding unit part data. chance-corrected values beta reliabilites stored $beta range 0 1. 0 indicates beta reliability equals beta reliability case complete guessing. 1 indicate absence beta errors. current example, chance-corrected beta reliabilities relatively high. means different categories strongly influenced errors categories.","code":"results$beta #>             A         B         C #> [1,] 0.746875 0.6835938 0.6203125"},{"path":"/articles/vig_Iota_1.html","id":"the-iota-values","dir":"Articles","previous_headings":"2 Example for using iotarelr in practice","what":"2.4 The iota values","title":"Old 1) How to use Iota1","text":"Iota values summarize different types errors category averaging chance-corrected reliabilities. stored $iota. Iota can range 0 1. 0 indicates quality coding category equals random guessing. Codings category reliable. 1 indicates perfect reliability category. , true value coding unit recovered true category category investigation errors made coding coding units categories note influence data category investigation. current example category quite reliable categories .","code":"results$iota #>              A         B         C #> [1,] 0.6558036 0.4121094 0.4111607"},{"path":"/articles/vig_Iota_1.html","id":"assignment-error-matrix-aem","dir":"Articles","previous_headings":"2 Example for using iotarelr in practice","what":"2.5 Assignment-Error Matrix (AEM)","title":"Old 1) How to use Iota1","text":"assignment-error matrix combines alpha beta values provides detailed description coding scheme. based raw estimates without chance-correction. AEM read row row rows represent true category coding unit columns represent assigned categories. values diagonal represent alpha-error categories. probability assign true category coding unit. cells describe probability assign category categories. , inform probability choose category condition true category recovered. example, alpha-error category .43 meaning coding unit category coded another category 43 %. words: probability assign true category coding unit category 57%. Thus, second third cell first row mean: true category coding unit belonging category recovered, 45% codings assigned category B 55% codings assigned category C. Thus, category C suffers errors made coding units truly belonging category category B. alpha-error category B .85. Thus 85% cases coding units truly belonging category B assigned another category. words: probability recover true category 15 % true category coding unit B. case error occurs, 40% cases assigned category 60 % assigned category C. Thus, data category C suffers errors made coding units belonging truly category B category . alpha-error category C 79%. Thus, 79% cases coding unit truly belonging category C assigned category B. error occurs 44 % codings units treated category 56% treated category B. consequence, category B suffers form errors made codings units category C category . words: data category B strongly biased errors category C data category .","code":"results$assignment_error_matrix #>           A         B         C #> A 0.4285714 0.4545455 0.5454545 #> B 0.4000000 0.8461538 0.6000000 #> C 0.4444444 0.5555556 0.7857143"},{"path":"/articles/vig_Iota_1.html","id":"scale-level","dir":"Articles","previous_headings":"2 Example for using iotarelr in practice","what":"2.6 Scale level","title":"Old 1) How to use Iota1","text":"measures described provide detailed insights reliability every single category new feature content analysis helpful constructing coding scheme evaluating data empirical studies. many applications however, values summarized values representing quality complete coding scheme. Iota Concept done averaging iota values category. value accessible $average_iota. current example average iota .49. moment rule thumb ordinal data exist. According Berding et al. (2022) average iota least .474 necessary acceptable level reliability scale level. “good” reliability average iota least .601.","code":"results$average_iota #> [1] 0.4930246"},{"path":"/articles/vig_Iota_1.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Old 1) How to use Iota1","text":"Berding, F., Elisabeth r., Simone S., Jahncke, H., Slopinski, ., Rebmann, K. (2022). Performance Configuration Artificial Intelligence Educational Settings. Introducing New Reliability Concept Based Content Analysis. Frontiers Education. https://doi.org/10.3389/feduc.2022.818365 Krippendorff, K. (2019). Content Analysis: Introduction Methodology Schreier, M. (2012). Qualitative Content Analysis Practice. SAGE.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Berding Florian. Author, maintainer. Pargmann Julia. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Florian Berding Julia Pargmann (2022).Iota Reliability Concept     Second Generation.Measures Content Analysis Done     Humans Artificial Intelligence. Berlin: Logos.     <https://doi.org/10.30819/5581>","code":"@Book{,   title = {Iota Reliability Concept of the Second Generation. Measures for Content Analysis Done by Humans or Artificial Intelligence.},   author = {Florian Berding and Julia Pargmann},   year = {2022},   publisher = {Logos},   series = {Berufs- und Wirtschaftspädagogik},   editor = {Florian Berding and Tobias Schlömer},   url = {https://www.logos-verlag.de/cgi-bin/engbuchmid?isbn=5581&lng=eng&id=},   doi = {10.30819/5581}, }"},{"path":"/index.html","id":"iotarelr---iota-inter-coder-reliability-for-content-analysis","dir":"","previous_headings":"","what":"Iota Inter Coder Reliability for Content Analysis","title":"Iota Inter Coder Reliability for Content Analysis","text":"iotarelr provides routines tools assessing quality content analysis basis Iota Reliability Concept. concept inspired item response theory can applied kind content analysis uses standardized coding scheme discrete categories. also applicable content analysis conducted artificial intelligence. package provides reliability measures complete scale well every single category. Analysis subgroup-invariance error corrections implemented. information can support development process coding scheme allows detailed inspection quality generated data. tools able provide answers following questions: reliable scale coding scheme? reliable single category within scale? coding scheme work similarly different groups materials different groups people? coding errors bias generated data? can generated data corrected errors?","code":""},{"path":"/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Iota Inter Coder Reliability for Content Analysis","text":"brief introduction use package can found via Get started. Articles describing conduct advanced analysis can found via Articles.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Iota Inter Coder Reliability for Content Analysis","text":"can install package CRAN : can install development version iotarelr GitHub :","code":"install.packages(\"iotarelr\") # install.packages(\"devtools\") devtools::install_github(\"FBerding/iotarelr\")"},{"path":"/index.html","id":"components","dir":"","previous_headings":"","what":"Components","title":"Iota Inter Coder Reliability for Content Analysis","text":"iotarelr calculates following components Iota Reliability Concept. level every single category: Assignment Error Matrix: Matrix containing probabilities assign coding unit truly belonging category category j. Alpha Reliability: Probability assign coding unit category category . Beta Reliability: Probability assign coding unit category j category . Iota: Value ranging 0 1, reflecting well generated data category really reflects category . Iota Error : Value describing many coding units missing data category . Iota Error II: Value describing many coding units categories part data category . scale level: Iota Index: Measure describing reliability scale. Zero indicates absence reliability. One indicates perfect reliability. Dynamic Iota Index: Transformation original Iota Index account uncertainty reliability estimation. Zero indicates absence reliability. One indicates perfect reliability.","code":""},{"path":"/index.html","id":"accuracy-of-reliability-estimates","dir":"","previous_headings":"","what":"Accuracy of Reliability Estimates","title":"Iota Inter Coder Reliability for Content Analysis","text":"parameter estimation components makes use Maximum Likelihood Estimation (Expectation Maximization Algorithm), comprises additional conditioning stage. following figure shows extent estimated parameters correspond true values based simulation study (Berding & Pargmann 2022). Click enlarge figure. Figure 1 - Accuracy Parameter Estimation general, parameter (Primary Parameters, Alpha Beta Reliability) estimates deviate true values 5 percentage points (see median figure). cases, Iota Index deviates .043 true value. estimates accurate, greater sample size raters involved coding. Furthermore, estimates accurate higher values true reliability. Please note high deviation Beta Reliability condition high reliability results rare cases perfect Alpha Reliability. details please refer Berding & Pargmann (2022).","code":""},{"path":"/index.html","id":"predictive-power","dir":"","previous_headings":"","what":"Predictive Power","title":"Iota Inter Coder Reliability for Content Analysis","text":"Studies investigated power Iota Concept predicting quality data generated content analysis compared Iota measures existing measures inter-coder reliability. figure shows R² nominal ordinal data. enlarge figure nominal data, click . Figure 2 - Predictive Power Nominal Data case nominal data, Dynamic Iota Index performs similarly even better Krippendorff’s Alpha predicting deviation estimated sample association true sample association. Alike applies estimating risk Type errors chance correctly classifying effect size categories proposed Cohen (1988). Figure 3 - Predictive Power Ordinal Data case ordinal data, Dynamic Iota Index shows slightly inferior performance compared Krippendorff’s Alpha, predictive power measures remains high. enlarge figure ordinal data, click .","code":""},{"path":"/index.html","id":"cut-off-values","dir":"","previous_headings":"","what":"Cut-Off Values","title":"Iota Inter Coder Reliability for Content Analysis","text":"Iota Concept provides cut-values several measures scale level. following table reports values currently recommended. minimal values imply expectation estimated true association/correlation deviate .3. Furthermore, values justify expectation risk Type errors less 10%. cut-value satisfactory justifies expectation estimated true association/correlation deviate .1 risk Type errors less 5%. values good imply estimated true association/correlation deviate .3 certainty 95%. Furthermore, values guarantee risk Type errors less 10 % certainty 95%. Values category excellent ensure certainty 95% risk Type errors less 5% deviation estimated true sample association/correlation exceeds .1. Please note degree certainty completely reached measures. presented cut-values rules thumb. derived situations demanding reliability. situation-specific cut-values can calculated function get_consequences(). Please refer vignette “Calculating consequences cut-values”.","code":""},{"path":"/index.html","id":"further-readings","dir":"","previous_headings":"","what":"Further Readings","title":"Iota Inter Coder Reliability for Content Analysis","text":"Florian Berding Julia Pargmann (2022). Iota Reliability Concept Second Generation. Measures Content Analysis Done Humans Artificial Intelligence. Berlin: Logos. https://doi.org/10.30819/5581 Florian Berding, Elisabeth Riebenbauer, Simone Stuetz, Heike Jahncke, Andreas Slopinski, Karin Rebmann (2022). Performance Configuration Artificial Intelligence Educational Settings. Introducing New Reliability Concept Based Content Analysis. Frontiers Education. https://doi.org/10.3389/feduc.2022.818365","code":""},{"path":"/reference/check_conformity_c.html","id":null,"dir":"Reference","previous_headings":"","what":"Check assumptions of weak superiority — check_conformity_c","title":"Check assumptions of weak superiority — check_conformity_c","text":"function tests probabilities within Assignment Error Matrix line assumption weak superiority.","code":""},{"path":"/reference/check_conformity_c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check assumptions of weak superiority — check_conformity_c","text":"","code":"check_conformity_c(aem)"},{"path":"/reference/check_conformity_c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check assumptions of weak superiority — check_conformity_c","text":"aem matrix probabilities","code":""},{"path":"/reference/check_conformity_c.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check assumptions of weak superiority — check_conformity_c","text":"Returns number violations assumption weak superiority. 0 assumptions fulfilled.","code":""},{"path":"/reference/check_conformity_c.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Check assumptions of weak superiority — check_conformity_c","text":"Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. https://doi.org/10.30819/5581","code":""},{"path":"/reference/check_dgf.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for Different Guidance Functioning (DGF) — check_dgf","title":"Check for Different Guidance Functioning (DGF) — check_dgf","text":"Function checking coding scheme different sub-groups.","code":""},{"path":"/reference/check_dgf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for Different Guidance Functioning (DGF) — check_dgf","text":"","code":"check_dgf(   data,   splitcr,   random_starts = 300,   max_iterations = 5000,   cr_rel_change = 1e-12,   con_step_size = 1e-04,   con_random_starts = 10,   con_max_iterations = 5000,   con_rel_convergence = 1e-12,   b_min = 0.01,   trace = FALSE,   con_trace = FALSE,   fast = TRUE )"},{"path":"/reference/check_dgf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for Different Guidance Functioning (DGF) — check_dgf","text":"data Data elements estimated. Data must object type data.frame matrix cases rows raters columns. Please note additional variables allowed object. splitcr Vector containing assignments coding units groups. vector must length number rows object data. random_starts integer number random starts EM algorithm. max_iterations integer maximum number iterations within EM algorithm. cr_rel_change Positive numeric value defining convergence EM algorithm. con_step_size Double specifying size increasing decreasing probabilities conditioning stage estimation. value less 1e-3. con_random_starts Integer number random starts within condition stage. con_max_iterations Integer maximum number iterations condition stage. con_rel_convergence Double determining convergence criterion condition stage. algorithm stops relative change smaller criterion. b_min Value ranging 0 1 determining minimal size categories checking boundary values occurred. algorithm tries select solutions considered boundary values. trace TRUE printing progress information console. FALSE information printed. con_trace TRUE printing progress information console estimations condition stage. FALSE information printed. fast Bool TRUE fast estimation applied condition stage. option ignores parameters beginning \"con_\". FALSE estimation described Berding Pargmann (2022) used. Default TRUE.","code":""},{"path":"/reference/check_dgf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for Different Guidance Functioning (DGF) — check_dgf","text":"Returns object class iotarelr_iota2_dif. group, results estimation saved separately. structure within group similar results compute_iota2(). Please check documentation.","code":""},{"path":"/reference/check_dgf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Check for Different Guidance Functioning (DGF) — check_dgf","text":"Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. https://doi.org/10.30819/5581","code":""},{"path":"/reference/check_new_rater.html","id":null,"dir":"Reference","previous_headings":"","what":"Check new rater — check_new_rater","title":"Check new rater — check_new_rater","text":"Function estimating reliability codings new rater based Iota 2","code":""},{"path":"/reference/check_new_rater.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check new rater — check_new_rater","text":"","code":"check_new_rater(   true_values,   assigned_values,   con_step_size = 1e-04,   con_random_starts = 5,   con_max_iterations = 5000,   con_rel_convergence = 1e-12,   con_trace = FALSE,   fast = TRUE )"},{"path":"/reference/check_new_rater.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check new rater — check_new_rater","text":"true_values Vector containing true categories coding units. Vector must length assigned_values. assigned_values Vector containing assigned categories coding units. Missing values currently supported omitted vector. Vector must length true_values. con_step_size Double specifying size increasing decreasing probabilities conditioning stage estimation. value less 1e-3. con_random_starts Integer number random starts within condition stage. con_max_iterations Integer maximum number iterations conditioning stage. con_rel_convergence Double determining convergence criterion conditioning stage. algorithm stops relative change smaller criterion. con_trace TRUE printing progress information console estimations conditioning stage. FALSE want information printed. fast Bool TRUE fast estimation applied condition stage. option ignores parameters beginning \"con_\". FALSE estimation described Berding Pargmann (2022) used. Default TRUE.","code":""},{"path":"/reference/check_new_rater.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check new rater — check_new_rater","text":"Returns list following three components: first component estimates_categorical_level comprises elements describe ratings categorical level. elements sub-divided raw estimates chance-corrected estimates. raw_estimates alpha_reliability: vector containing Alpha Reliabilities category. values represent probabilities. beta_reliability: vector containing Beta Reliabilities category. values represent probabilities. assignment_error_matrix: Assignment Error Matrix containing conditional probabilities assigning unit category categories 1 n. #' iota:  vector containing Iota values category. elements_chance_corrected alpha_reliability:  vector containing chance-corrected Alpha Reliabilities category. beta_reliability:  vector containing chance-corrected Beta Reliabilities category. second component estimates_scale_level contains elements describe quality ratings scale level. contains following elements: iota_index:  Iota Index representing reliability scale level. iota_index_d4:  Static Iota Index, transformation original Iota Index, order consider uncertainty estimation. iota_index_dyn2:  Dynamic Iota Index, transformation original Iota Index, order consider uncertainty estimation. third component information contains important information regarding parameter estimation. comprises following elements: log_likelihood:  Log-likelihood best solution. convergence:  estimation converged 0, otherwise 1. est_true_cat_sizes:  Estimated categorical sizes. estimated amount categories. conformity:  0 solution line assumptions weak superiority.  number greater 0 indicates number violations assumption  weak superiority. random_starts:  Numer random starts EM algorithm. boundaries:  False best solution contain boundary values. True best solution contain boundary values p_boundaries:  Percentage solutions boundary values estimation. call:  Name function created object. n_rater:  Number raters. n_cunits:  Number coding units.","code":""},{"path":"/reference/check_new_rater.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check new rater — check_new_rater","text":"returned object contains slots since returned object class iotarelr_iota2. slots empty part estimation within function.","code":""},{"path":"/reference/check_new_rater.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Check new rater — check_new_rater","text":"Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. https://doi.org/10.30819/5581","code":""},{"path":"/reference/compute_iota1.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes Iota and its elements in version 1 — compute_iota1","title":"Computes Iota and its elements in version 1 — compute_iota1","text":"Computes elements Iota Reliability Concept","code":""},{"path":"/reference/compute_iota1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes Iota and its elements in version 1 — compute_iota1","text":"","code":"compute_iota1(data)"},{"path":"/reference/compute_iota1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes Iota and its elements in version 1 — compute_iota1","text":"data Data elements estimated. Data must object type data.frame matrix  cases rows raters columns.","code":""},{"path":"/reference/compute_iota1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes Iota and its elements in version 1 — compute_iota1","text":"list following components alpha vector containing chance-corrected Alpha Reliabilities every category. beta vector containing chance-corrected Beta Reliabilities every category. iota vector containing Iota values every category. assignment_error_matrix matrix conditional probabilities every category. rows refer true categories columns refer assigned categories. elements diagonal represent alpha errors category. elements row represent conditioned probabilities coding unit wrongly assigned another category. average_iota numeric value ranging 0 1, representing Average Iota values categorical level. describes reliability whole scale.","code":""},{"path":"/reference/compute_iota1.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computes Iota and its elements in version 1 — compute_iota1","text":"-   Berding, Florian, Elisabeth Riebenbauer, Simone Stuetz, Heike Jahncke, Andreas Slopinski, Karin Rebmann. 2022. Performance Configuration Artificial Intelligence Educational Settings.Introducing New Reliability Concept Based Content Analysis. Frontiers Education. https://doi.org/10.3389/feduc.2022.818365","code":""},{"path":"/reference/compute_iota2.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes Iota and its elements in version 2 — compute_iota2","title":"Computes Iota and its elements in version 2 — compute_iota2","text":"Fits model Iota2 data","code":""},{"path":"/reference/compute_iota2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes Iota and its elements in version 2 — compute_iota2","text":"","code":"compute_iota2(   data,   random_starts = 10,   max_iterations = 5000,   cr_rel_change = 1e-12,   con_step_size = 1e-04,   con_rel_convergence = 1e-12,   con_max_iterations = 5000,   con_random_starts = 5,   b_min = 0.01,   fast = TRUE,   trace = TRUE,   con_trace = FALSE )"},{"path":"/reference/compute_iota2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes Iota and its elements in version 2 — compute_iota2","text":"data Data elements estimated. Data must object type data.frame matrix cases rows raters columns. random_starts integer number random starts EM algorithm. max_iterations integer maximum number iterations within EM algorithm. cr_rel_change Positive numeric value defining convergence EM algorithm. con_step_size Double specifying size increasing decreasing probabilities conditioning stage estimation. value less 1e-3. con_rel_convergence Double determining convergence criterion conditioning stage. algorithm stops relative change smaller criterion. con_max_iterations Integer maximum number iterations conditioning stage. con_random_starts Integer number random starts within conditioning stage. b_min Value ranging 0 1, determining minimal size categories checking boundary values occurred. algorithm tries select solutions considered boundary values. fast Bool TRUE fast estimation applied condition stage. option ignores parameters beginning \"con_\". FALSE estimation described Berding Pargmann (2022) used. Default TRUE. trace TRUE printing progress information console. FALSE information printed. con_trace TRUE printing progress information console estimations conditioning stage. FALSE information printed.","code":""},{"path":"/reference/compute_iota2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes Iota and its elements in version 2 — compute_iota2","text":"Returns list following three components: first component estimates_categorical_level comprises elements describe ratings categorical level. elements sub-divided raw estimates chance-corrected estimates. raw_estimates alpha_reliability: vector containing Alpha Reliabilities category. values represent probabilities. beta_reliability: vector containing Beta Reliabilities category. values represent probabilities. assignment_error_matrix: Assignment Error Matrix containing conditional probabilities assigning unit category categories 1 n. iota:  vector containing Iota values category. iota_error_1:  vector containing Iota Error Type values category. iota_error_2:  vector containing Iota Error Type II values category. elements_chance_corrected alpha_reliability:  vector containing chance-corrected Alpha Reliabilities category. beta_reliability:  vector containing chance-corrected Beta Reliabilities category.","code":""},{"path":"/reference/compute_iota2.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computes Iota and its elements in version 2 — compute_iota2","text":"Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. https://doi.org/10.30819/5581","code":""},{"path":"/reference/EM_algo_c.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter estimation via EM Algorithm with Condition Stage — EM_algo_c","title":"Parameter estimation via EM Algorithm with Condition Stage — EM_algo_c","text":"Function written C++ estimating parameters model via Expectation Maximization (EM Algorithm).","code":""},{"path":"/reference/EM_algo_c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter estimation via EM Algorithm with Condition Stage — EM_algo_c","text":"","code":"EM_algo_c(   obs_pattern_shape,   obs_pattern_frq,   obs_internal_count,   categorical_levels,   random_starts,   max_iterations,   rel_convergence,   con_step_size,   con_random_starts,   con_max_iterations,   con_rel_convergence,   fast,   trace,   con_trace )"},{"path":"/reference/EM_algo_c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter estimation via EM Algorithm with Condition Stage — EM_algo_c","text":"obs_pattern_shape Matrix containing unique patterns found data. Ideally matrix generated function get_patterns(). obs_pattern_frq Vector containing frequencies patterns. Ideally generated function get_patterns(). obs_internal_count Matrix containing relative frequencies category within pattern. Ideally matrix generated function get_patterns(). categorical_levels Vector containing possible categories content analysis. random_starts Integer determining often algorithm restart randomly chosen values Assignment Error Matrix categorical sizes. max_iterations Integer determining maximum number iterations random start. rel_convergence Double determining convergence criterion. algorithm stops relative change smaller criterion. con_step_size Double specifying size increasing decreasing probabilities condition stage estimation. value less 1e-3. con_random_starts Integer number random starts within condition stage. con_max_iterations Integer maximum number iterations condition stage. con_rel_convergence Double determining convergence criterion condition stage. algorithm stops relative change smaller criterion. fast Bool TRUE fast estimation applied condition stage. option ignores parameters beginning \"con_\". FALSE estimation described Berding Pargmann (2022) used. Default TRUE. trace TRUE printing progress information console. FALSE information printed. con_trace TRUE printing progress information console estimations condition stage. FALSE information printed.","code":""},{"path":"/reference/EM_algo_c.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter estimation via EM Algorithm with Condition Stage — EM_algo_c","text":"Function returns list estimated parameter sets every random start. Every parameter set contains following components: log_likelihood Log likelihood estimated solution. aem Estimated Assignment Error Matrix (aem). rows represent true categories columns stand assigned categories. cells describe probability coding unit category assigned category j. categorial_sizes Vector estimated sizes category. convergence algorithm converged within iteration limit TRUE. FALSE every case. iteration Number iterations algorithm terminated.","code":""},{"path":"/reference/EM_algo_c.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Parameter estimation via EM Algorithm with Condition Stage — EM_algo_c","text":"Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. https://doi.org/10.30819/5581","code":""},{"path":"/reference/est_con_multinominal_c.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimating log likelihood in Condition Stage — est_con_multinominal_c","title":"Estimating log likelihood in Condition Stage — est_con_multinominal_c","text":"Function written C++ estimating log likelihood given parameter set condition stage.","code":""},{"path":"/reference/est_con_multinominal_c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimating log likelihood in Condition Stage — est_con_multinominal_c","text":"","code":"est_con_multinominal_c(   observations,   anchor,   max_iter = 500000L,   step_size = 1e-04,   cr_rel_change = 1e-12,   n_random_starts = 10L,   fast = TRUE,   trace = FALSE )"},{"path":"/reference/est_con_multinominal_c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimating log likelihood in Condition Stage — est_con_multinominal_c","text":"observations NumericVector containing frequency categories. anchor Integer ranging 1 number categories. Anchor defines reference category. category highest probability according assumption weak superiority. max_iter Integer specifying maximal number iterations random start. step_size Double specifying size increasing decreasing probabilities estimation. value less 1e-3. cr_rel_change Double defining estimation stop. , change log-likelihood smaller value estimation stops. n_random_starts Integer number random start. fast Bool TRUE fast estimation applied. option ignored parameters. FALSE estimation described Berding Pargmann (2022) used. Default TRUE. trace Bool TRUE information progress estimation printed console. FALSE desired.","code":""},{"path":"/reference/est_con_multinominal_c.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimating log likelihood in Condition Stage — est_con_multinominal_c","text":"Returns log likelihood single numeric value.","code":""},{"path":"/reference/est_con_multinominal_c.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimating log likelihood in Condition Stage — est_con_multinominal_c","text":"Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. https://doi.org/10.30819/5581","code":""},{"path":"/reference/est_expected_categories.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Expected Categories — est_expected_categories","title":"Estimate Expected Categories — est_expected_categories","text":"Function estimating expected category coding units.","code":""},{"path":"/reference/est_expected_categories.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Expected Categories — est_expected_categories","text":"","code":"est_expected_categories(data, aem)"},{"path":"/reference/est_expected_categories.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Expected Categories — est_expected_categories","text":"data Matrix contains codings every coding unit. coding units must rows raters must columns. least two raters necessary. aem Assignment Error Matrix based second generation Iota Concept (Iota2).","code":""},{"path":"/reference/est_expected_categories.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Expected Categories — est_expected_categories","text":"Returns matrix original data, conditioned probability true category, expected category every coding unit.","code":""},{"path":"/reference/fct_log_likelihood_c.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimating log-likelihood — fct_log_likelihood_c","title":"Estimating log-likelihood — fct_log_likelihood_c","text":"Function written C++ estimating log likelihood given parameter set.","code":""},{"path":"/reference/fct_log_likelihood_c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimating log-likelihood — fct_log_likelihood_c","text":"","code":"fct_log_likelihood_c(   categorial_sizes,   aem,   obs_pattern_shape,   obs_pattern_frq,   categorical_levels )"},{"path":"/reference/fct_log_likelihood_c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimating log-likelihood — fct_log_likelihood_c","text":"categorial_sizes Vector containing sizes different categories. amount category cases. aem Matrix aem form. matrix reports true category rows assigned categories columns. cells represent probabilities coding unit category assigned category j. obs_pattern_shape Matrix containing unique patterns found data. Ideally matrix generated function get_patterns(). obs_pattern_frq Vector containing frequencies patterns. Ideally generated function get_patterns(). categorical_levels Vector containing possible categories content analysis.","code":""},{"path":"/reference/fct_log_likelihood_c.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimating log-likelihood — fct_log_likelihood_c","text":"Returns log likelihood single numeric value.","code":""},{"path":"/reference/fct_log_likelihood_c.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimating log-likelihood — fct_log_likelihood_c","text":"Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. https://doi.org/10.30819/5581","code":""},{"path":"/reference/get_consequences.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Consequences — get_consequences","title":"Get Consequences — get_consequences","text":"Function estimating consequences reliability subsequent analysis.","code":""},{"path":"/reference/get_consequences.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Consequences — get_consequences","text":"","code":"get_consequences(   measure_typ = \"dynamic_iota_index\",   measure_1_val,   measure_2_val = NULL,   level = 0.95,   strength = NULL,   data_type,   sample_size )"},{"path":"/reference/get_consequences.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Consequences — get_consequences","text":"measure_typ Type measure used estimation. Set \"iota_index\" original Iota Index, \"static_iota_index\" static transformation Iota Index d=4 \"dynamic_iota_index\" dynamic transformation Iota Index d=2. measure_1_val Reliability value independent variable. measure_2_val Reliability value dependent variable. set, function uses value independent variable. level Level certainty calculating prediction intervals. strength True strength relationship independent dependent variable. Possible values \"\", \"weak\", \"medium\" \"strong\". value supplied, strong relationship assumed deviation weak relationship others. represent demanding situations reliability. data_type Type data. Possible values \"nominal\" \"ordinal\". sample_size Size sample study.","code":""},{"path":"/reference/get_consequences.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Consequences — get_consequences","text":"Returns data.frame contains prediction intervals deviation  true estimated sample association/correlation, risk Type errors chance correctly classify effect size. Additionally, probability estimated statistics sample deviate error free sample weak effect .","code":""},{"path":"/reference/get_consequences.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Get Consequences — get_consequences","text":"classification effect sizes uses work Cohen (1988), differentiates effect sizes relevance practice. nominal data, statistics refer Cramer's V. ordinal data, statistics refer Kendall's Tau. models calculating consequences taken Berding Pargmann (2022).","code":""},{"path":"/reference/get_consequences.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Get Consequences — get_consequences","text":"Cohen, J. (1988). Statistical Power Analysis Behavioral Sciences (2nd Ed.). Taylor & Francis. Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. https://doi.org/10.30819/5581","code":""},{"path":"/reference/get_iota2_measures.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Iota2 Measures — get_iota2_measures","title":"Get Iota2 Measures — get_iota2_measures","text":"Function calculating elements Iota Concept 2","code":""},{"path":"/reference/get_iota2_measures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Iota2 Measures — get_iota2_measures","text":"","code":"get_iota2_measures(aem, categorical_sizes, categorical_levels)"},{"path":"/reference/get_iota2_measures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Iota2 Measures — get_iota2_measures","text":"aem Assignment Error Matrix. categorical_sizes Probabilities different categories occur. categorical_levels Vector containing possible categories content analysis.","code":""},{"path":"/reference/get_iota2_measures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Iota2 Measures — get_iota2_measures","text":"Returns list measures belonging Iota Concept second generation. first component estimates_categorical_level comprises elements describe ratings categorical level. elements sub-divided raw estimates chance-corrected estimates. raw_estimates iota:  vector containing Iota values category. iota_error_1:  vector containing Iota Error Type values category. iota_error_2:  vector containing Iota Error Type II values category. alpha_reliability: vector containing Alpha Reliabilities category. values represent probabilities. beta_reliability: vector containing Beta Reliabilities category. values represent probabilities. assignment_error_matrix: Assignment Error Matrix containing conditional probabilities assigning unit category categories 1 n. elements_chance_corrected alpha_reliability:  vector containing chance-corrected Alpha Reliabilities category. beta_reliability:  vector containing chance-corrected Beta Reliabilities category. second component estimates_scale_level contains elements describing quality ratings scale level. comprises following elements: iota_index:  Iota Index, representing reliability scale level. iota_index_d4:  Static Iota Index, transformation original Iota Index, order consider uncertainty estimation. iota_index_dyn2:  Dynamic Iota Index, transformation original Iota Index, order consider uncertainty estimation.","code":""},{"path":"/reference/get_iota2_measures.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Get Iota2 Measures — get_iota2_measures","text":"Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. https://doi.org/10.30819/5581","code":""},{"path":"/reference/get_patterns.html","id":null,"dir":"Reference","previous_headings":"","what":"Get patterns — get_patterns","title":"Get patterns — get_patterns","text":"Auxiliary function written R providing necessary information patterns generated raters. function produces input EM-algorithm.","code":""},{"path":"/reference/get_patterns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get patterns — get_patterns","text":"","code":"get_patterns(data, categorical_levels)"},{"path":"/reference/get_patterns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get patterns — get_patterns","text":"data Matrix data.frame containing ratings. cases rows raters columns. Characters cells supported. least two raters necessary. categorical_levels Vector containing possible categories content analysis.","code":""},{"path":"/reference/get_patterns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get patterns — get_patterns","text":"Function returns list following components: n Integer representing number different patterns data. shape Matrix containing unique patterns data. Cells matrix characters. frq Vector containing frequencies patterns. count Matrix containing relative frequencies categories within pattern. number rows equals number patterns. number columns equals number categories.","code":""},{"path":"/reference/get_random_start_values_class_sizes.html","id":null,"dir":"Reference","previous_headings":"","what":"Generating randomly chosen probabilities for categorical sizes — get_random_start_values_class_sizes","title":"Generating randomly chosen probabilities for categorical sizes — get_random_start_values_class_sizes","text":"Function written C++ generating set randomly chosen probabilities describing size different classes. probabilities describe relative frequencies categories data.","code":""},{"path":"/reference/get_random_start_values_class_sizes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generating randomly chosen probabilities for categorical sizes — get_random_start_values_class_sizes","text":"","code":"get_random_start_values_class_sizes(n_categories)"},{"path":"/reference/get_random_start_values_class_sizes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generating randomly chosen probabilities for categorical sizes — get_random_start_values_class_sizes","text":"n_categories Integer number categories data. Must least 2.","code":""},{"path":"/reference/get_random_start_values_class_sizes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generating randomly chosen probabilities for categorical sizes — get_random_start_values_class_sizes","text":"Returns vector randomly chosen categorical sizes.","code":""},{"path":"/reference/get_random_start_values_p.html","id":null,"dir":"Reference","previous_headings":"","what":"Generating randomly chosen probabilities for Assignment Error Matrix — get_random_start_values_p","title":"Generating randomly chosen probabilities for Assignment Error Matrix — get_random_start_values_p","text":"Function written C++ generating set randomly chosen probabilities Assignment Error Matrix.","code":""},{"path":"/reference/get_random_start_values_p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generating randomly chosen probabilities for Assignment Error Matrix — get_random_start_values_p","text":"","code":"get_random_start_values_p(n_categories)"},{"path":"/reference/get_random_start_values_p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generating randomly chosen probabilities for Assignment Error Matrix — get_random_start_values_p","text":"n_categories Integer number categories data. Must least 2.","code":""},{"path":"/reference/get_random_start_values_p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generating randomly chosen probabilities for Assignment Error Matrix — get_random_start_values_p","text":"Returns matrix Assignment Error Matrix (AEM) randomly generated probabilities. generated probabilities line assumption weak superiority.","code":""},{"path":"/reference/get_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Summary — get_summary","title":"Get Summary — get_summary","text":"Function creating short summary estimated Iota components.","code":""},{"path":"/reference/get_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Summary — get_summary","text":"","code":"get_summary(object)"},{"path":"/reference/get_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Summary — get_summary","text":"object object class iotarelr_iota2 created compute_iota2, check_new_rater, check_dgf.","code":""},{"path":"/reference/get_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Summary — get_summary","text":"Prints central statistics estimated model.","code":""},{"path":"/reference/grad_ll.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient for Log Likelihood in Condition Stage — grad_ll","title":"Gradient for Log Likelihood in Condition Stage — grad_ll","text":"Function written C++ estimating gradient log likelihood function given parameter set given observations.","code":""},{"path":"/reference/grad_ll.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient for Log Likelihood in Condition Stage — grad_ll","text":"","code":"grad_ll(param_values, observations)"},{"path":"/reference/grad_ll.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient for Log Likelihood in Condition Stage — grad_ll","text":"param_values NumericVector containing probabilities multinominal distribution. length factor number categories - 1 since contains parameters estimated. observations NumericVector containing number observations category multinominal distribution. length vector equals number categories.","code":""},{"path":"/reference/grad_ll.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient for Log Likelihood in Condition Stage — grad_ll","text":"Returns gradient NumericVector.","code":""},{"path":"/reference/grad_ll.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Gradient for Log Likelihood in Condition Stage — grad_ll","text":"Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. https://doi.org/10.30819/5581","code":""},{"path":"/reference/iotarelr_new_rater.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample Vector — iotarelr_new_rater","title":"Sample Vector — iotarelr_new_rater","text":"vector containing ratings new rater. data real created illustration purposes.","code":""},{"path":"/reference/iotarelr_new_rater.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample Vector — iotarelr_new_rater","text":"","code":"iotarelr_new_rater"},{"path":"/reference/iotarelr_new_rater.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample Vector — iotarelr_new_rater","text":"vector length 318.","code":""},{"path":"/reference/iotarelr_written_exams.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Data Set — iotarelr_written_exams","title":"Example Data Set — iotarelr_written_exams","text":"data set containing ratings three coders written exams. also contains gender people took exam. data real created illustrating purposes.","code":""},{"path":"/reference/iotarelr_written_exams.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Data Set — iotarelr_written_exams","text":"","code":"iotarelr_written_exams"},{"path":"/reference/iotarelr_written_exams.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Data Set — iotarelr_written_exams","text":"data frame 318 rows 4 variables: Coder Ratings coder . Coder B Ratings coder B. Coder C Ratings coder C. Sex Referring biological aspects individual.","code":""},{"path":"/reference/log_likelihood_multi_c.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimating log-likelihood in Condition Stage — log_likelihood_multi_c","title":"Estimating log-likelihood in Condition Stage — log_likelihood_multi_c","text":"Function written C++ estimating log likelihood given parameter set condition stage.","code":""},{"path":"/reference/log_likelihood_multi_c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimating log-likelihood in Condition Stage — log_likelihood_multi_c","text":"","code":"log_likelihood_multi_c(probabilities, observations)"},{"path":"/reference/log_likelihood_multi_c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimating log-likelihood in Condition Stage — log_likelihood_multi_c","text":"probabilities NumericVector containing probabilities multinominal distribution. context Iota Reliability refers specific row Assignment Error Matrix. observations NumericVector containing number observations category multinominal distribution.","code":""},{"path":"/reference/log_likelihood_multi_c.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimating log-likelihood in Condition Stage — log_likelihood_multi_c","text":"Returns log likelihood single numeric value.","code":""},{"path":"/reference/log_likelihood_multi_c.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimating log-likelihood in Condition Stage — log_likelihood_multi_c","text":"Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. https://doi.org/10.30819/5581","code":""},{"path":"/reference/plot_iota.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Iota2 — plot_iota","title":"Plot Iota2 — plot_iota","text":"Function creating plot object can plotted via ggplot2.","code":""},{"path":"/reference/plot_iota.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Iota2 — plot_iota","text":"","code":"plot_iota(   object,   xlab = \"Amount on all cases\",   ylab = \"Categories\",   liota = \"Assignment of the true category (Iota)\",   lcase2 = \"Assignment to the false category\",   lcase3 = \"Assignment from the false true category\",   lscale_quality = \"Scale Quality\",   lscale_cat = c(\"insufficent\", \"minimum\", \"satisfactory\", \"good\", \"excellent\"),   number_size = 6,   key_size = 0.5,   text_size = 10,   scale = \"none\" )"},{"path":"/reference/plot_iota.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Iota2 — plot_iota","text":"object Estimates Iota 2 created compute_iota2(), check_dgf() check_new_rater(). xlab Character passed xlab() scale_fill_manual(). Label x-axis. ylab Character passed ylab() scale_fill_manual(). Label y-axis. liota Character passed labels() scale_fill_manual(). Label Iota.Amount cases assigned correct category. lcase2 Character passed labels() scale_fill_manual(). Label amount cases assigned false category. lcase3 Character passed labels() scale_fill_manual(). Label amount cases assigned false category. lscale_quality character passed scale_fill_manual() determining title quality scale. used conjunction scale. lscale_cat Vector strings length 5. vector contains labels category quality scale. number_size Double passed geom_text() determining size numbers within plot. key_size Double passed theme() determining size legend keys. text_size Double passed theme() determining size text within legend. scale String requesting additional plot reliability scale level. scale=\"dynamic_iota_index\" Dynamic Iota Index used.  scale=\"static_iota_index\" Static Iota Index used. scale=\"none\" additional plot created.","code":""},{"path":"/reference/plot_iota.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Iota2 — plot_iota","text":"Function returns object class gg, ggplot illustrating data different categories influence .","code":""},{"path":"/reference/plot_iota.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Plot Iota2 — plot_iota","text":"example interpreting plot can found vignette Get started via vignette(\"iotarelr\", package = \"iotarelr\").","code":""},{"path":"/reference/plot_iota.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot Iota2 — plot_iota","text":"Berding, Florian, Pargmann, Julia (2022).Iota Reliability Concept Second Generation.Measures Content Analysis Done Humans Artificial Intelligences. Berlin: Logos. https://doi.org/10.30819/5581","code":""},{"path":"/reference/plot_iota2_alluvial.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot of the Coding Stream — plot_iota2_alluvial","title":"Plot of the Coding Stream — plot_iota2_alluvial","text":"Function creating alluvial plot can plotted via ggplot2.","code":""},{"path":"/reference/plot_iota2_alluvial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot of the Coding Stream — plot_iota2_alluvial","text":"","code":"plot_iota2_alluvial(   object,   label_titel = \"Coding Stream from True to Assigned Categories\",   label_prefix_true = \"true\",   label_prefix_assigned = \"labeled as\",   label_legend_title = \"True Categories\",   label_true_category = \"True Category\",   label_assigned_category = \"Assigned Category\",   label_y_axis = \"Relative Frequencies\",   label_categories_size = 3,   key_size = 0.5,   text_size = 10 )"},{"path":"/reference/plot_iota2_alluvial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot of the Coding Stream — plot_iota2_alluvial","text":"object Estimates Iota 2 created compute_iota2(), check_new_rater() check_dgf(). Please note object created check_dgf() passed directly. elements corresponding list compatible. label_titel Character containing title plot. label_prefix_true Character representing prefix tagging true categories. Character applied every category. label_prefix_assigned Character representing prefix tagging assigned categories. Character applied every category. label_legend_title Character containing title legend. label_true_category Character describing stratum true categories. label_assigned_category Character describing stratum assigned categories. label_y_axis Character. Label y-axis. label_categories_size double determining size label true assigned category within plot. key_size double determining size legend. text_size double determining size text within legend.","code":""},{"path":"/reference/plot_iota2_alluvial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot of the Coding Stream — plot_iota2_alluvial","text":"Returns object class gg ggplot can shown plot().","code":""},{"path":"/reference/plot_iota2_alluvial.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Plot of the Coding Stream — plot_iota2_alluvial","text":"example interpreting plot can found vignette Get started via vignette(\"iotarelr\", package = \"iotarelr\").","code":""},{"path":"/news/index.html","id":"iotarelr-013-developer-version","dir":"Changelog","previous_headings":"","what":"iotarelr 0.1.3 (developer version)","title":"iotarelr 0.1.3 (developer version)","text":"Correction description citation files. Bug fixes Git Hub page iotarelr. Introducing new function plot_iota2_alluvial() allowing analysis coding streams. Adding fast estimation method condition stage increase stability results. new default functions estimating iota2 object.","code":""},{"path":"/news/index.html","id":"iotarelr-012","dir":"Changelog","previous_headings":"","what":"iotarelr 0.1.2","title":"iotarelr 0.1.2","text":"CRAN release: 2022-11-09 November 2022 Releasing iotarelr 0.1.2 Providing Iota Concept generation two.","code":""},{"path":"/news/index.html","id":"iotarelr-011","dir":"Changelog","previous_headings":"","what":"iotarelr 0.1.1","title":"iotarelr 0.1.1","text":"March 2022 Releasing iotarelr 0.1.1 Providing Iota Concept generation one.","code":""}]
