#include <Rcpp.h>
using namespace Rcpp;


//'Generating randomly chosen probabilities for aem-matrix
//'
//'Function written in \code{C++} for generating a set of randomly chosen
//'probabilities for the aem-Matrix.
//'@param n_categories Integer for the number of categories in the data. Must be
//'at least 2.
//'@return Returns a matrix for the assignment errors (AEM) with randomly
//'generated probabilities. The generated probabilities are in line with
//'the assumption of weak superiority.
//'@importFrom Rcpp sourceCpp
//'@useDynLib iotarelr
// [[Rcpp::export]]
Rcpp::NumericMatrix get_random_start_values_p(int n_categories){
  Rcpp::NumericMatrix random_aem(n_categories,n_categories);
  Rcpp::NumericVector p_range(100);
  Rcpp::NumericVector sample_vec;
  Rcpp::NumericVector diagonal_vec;
  Rcpp::NumericVector start_range;

  int i=0,j=0;
  double rowSum=0.0;

  start_range=seq(50,100);
  diagonal_vec=sample(start_range,
                      n_categories,
                      true,
                      R_NilValue);

  for(i=0; i<n_categories; i++){
    for(j=0; j<n_categories; j++){
      p_range=Rcpp::seq(1,diagonal_vec(i));
      sample_vec=Rcpp::sample(p_range,2,true,R_NilValue);
      random_aem(i,j)=sample_vec[0];
    }
    rowSum=Rcpp::sum(random_aem(i,_));

    for(j=0; j<n_categories; j++){
      random_aem(i,j)=random_aem(i,j)/rowSum;
    }

  }
  return random_aem;
}


//'Generating randomly chosen probabilities for categorical sizes
//'
//'Function written in \code{C++} for generating a set of randomly chosen
//'probabilities describing the size of the different classes. The
//'probabilities describe the relative frequencies of the categories in the data.
//'@param n_categories Integer for the number of categories in the data. Must be
//'at least 2.
//'@return Returns a vector of randomly chosen categorical sizes.
// [[Rcpp::export]]
Rcpp::NumericVector get_random_start_values_class_sizes(int n_categories){
  Rcpp::NumericVector random_class_sizes(n_categories);
  Rcpp::NumericVector p_range(100);
  Rcpp::NumericVector sample_vec;
  int i=0;
  double rowSum=0.0;

  p_range=Rcpp::seq(1,100);

  for(i=0; i<n_categories; i++){
    sample_vec=Rcpp::sample(p_range,2,true,R_NilValue);
    random_class_sizes(i)=sample_vec[0];
    }
  rowSum=Rcpp::sum(random_class_sizes);
  for(i=0; i<n_categories; i++){
      random_class_sizes(i)=random_class_sizes(i)/rowSum;
    }

  return random_class_sizes;
}

//' Estimating log-likelihood
//'
//' Function written in \code{C++} estimating the log-likelihood of a given
//' parameter set.
//'
//' @param categorial_sizes \code{Vector} containing the sizes of the different
//' categories. That is amount of a category on all cases.
//' @param aem \code{Matrix} in aem form. This matrix reports the truth category
//' in the rows and the assigned categories in the columns. The cells represent
//' the probabilities that a coding unit of category i is assigned to category j.
//' @param obs_pattern_shape \code{Matrix} containing the unique patterns found
//' in the data. Ideally this matrix is generated by the function
//' \code{\link{get_patterns}}.
//' @param obs_pattern_frq \code{Vector} containing the frequencies of the
//' patterns. Ideally it is generated by the the function
//' \code{\link{get_patterns}}.
//' @param categorical_levels \code{Vector} containing all possible categories of
//' the content analysis.
//' @return Returns the log-likelihood as a single numeric value.
// [[Rcpp::export]]
double fct_log_likelihood_c(Rcpp::NumericVector categorial_sizes,
                              Rcpp::NumericMatrix aem,
                              Rcpp::CharacterMatrix obs_pattern_shape,
                              Rcpp::NumericVector obs_pattern_frq,
                              Rcpp::CharacterVector categorical_levels){

 double log_ll=0.0;
 double tmp_pattern_p=0.0;
 double tmp_k_p=1.0;
 int i=0;
 int j=0;
 int k=0;
 String string_k;
 String string_j;

 CharacterVector aem_colnames=colnames(aem);
 CharacterVector aem_rownames=rownames(aem);

  for(i=0;i<obs_pattern_shape.nrow();i++){
    tmp_pattern_p=0.0;
    for(k=0; k<categorical_levels.length();k++){
      string_k=categorical_levels(k);
      tmp_k_p=1.0;

      for(j=0;j<obs_pattern_shape.ncol();j++){
        string_j=obs_pattern_shape(i,j);
        tmp_k_p=tmp_k_p*aem(categorial_sizes.findName(string_k),categorial_sizes.findName(string_j));
      }

      tmp_k_p=tmp_k_p*categorial_sizes(categorial_sizes.findName(string_k));
      tmp_pattern_p=tmp_pattern_p+tmp_k_p;
    }
    log_ll=log_ll+log(tmp_pattern_p)*obs_pattern_frq(i);
  }
  return(-log_ll);
}


//'Parameter estimation via EM-Algorithm
//'
//'Function written in \code{C++} for estimating the parameters of the model
//'via Expectation-Maximization(EM)-algorithm.
//' @param obs_pattern_shape \code{Matrix} containing the unique patterns found
//' in the data. Ideally this matrix is generated by the function
//' \code{\link{get_patterns}}.
//' @param obs_pattern_frq \code{Vector} containing the frequencies of the
//' patterns. Ideally it is generated by the the function
//' \code{\link{get_patterns}}.
//' @param obs_internal_count \code{Matrix} containing the relative frequencies
//' of each category within each pattern. Ideally this matrix is generated by
//' the function \code{\link{get_patterns}}.
//' @param categorical_levels \code{Vector} containing all possible categories of
//' the content analysis.
//'@param random_starts Integer for determining how often the algorithm should
//'restart with randomly chosen values for the aem matrix and the categorical
//'sizes.
//'@param max_iterations Integer for determining the maximum number of iterations
//'for each random start.
//'@param rel_convergence Double for determining the convergence criterion. The
//'algorithm stops if the relative change is smaller than this criterion.
//'@param trace \code{TRUE} for printing progress information on the console.
//'\code{FALSE} if this information should not be printed.
//'@return Function returns a \code{List} with the estimated parameter sets for
//'every random start. Every parameter set contains the following components:
//'\item{log_likelihood}{Log-likelihood of the estimated solution.}
//'\item{aem}{Estimated assignment-error-matrix (aem). The rows represent the
//'true categories while the columns stand for the assigned categories. The cells
//'describe the probability that a coding unit of category i is assigned to
//'category j.}
//'\item{categorial_sizes}{\code{Vector} of estimated sizes for each
//'category.}
//'\item{convergence}{If the algorithm converged within the iteration limit
//'\code{TRUE}. \code{FALSE} in every other case.}
//'\item{iteration}{Number of iterations when the algorithm was terminated.}
//'@export
// [[Rcpp::export]]
Rcpp::List EM_algo_c (Rcpp::CharacterMatrix obs_pattern_shape,
                      Rcpp::NumericVector obs_pattern_frq,
                      Rcpp::NumericMatrix obs_internal_count,
                      Rcpp::CharacterVector categorical_levels,
                      int random_starts,
                      int max_iterations,
                      double rel_convergence,
                      bool trace)
{
  Rcpp::List Estimates_collection;

  double rel_change=0.0;
  double pattern_p=0.0;
  double tmp_p=0.0;
  double tmp=0.0;

  int n_categories=categorical_levels.length();
  int n_pattern=obs_pattern_shape.nrow();
  int n_rater=obs_pattern_shape.ncol();
  int N=Rcpp::sum(obs_pattern_frq);

  int i=0;
  int iter=0;
  int p=0;
  int c=0;
  int r=0;
  int a=0;

  double new_ll=0.0;
  double old_ll=0.0;

  int index_c=0;
  int index_pr=0;
  String string_pr;

  Rcpp::NumericMatrix aem(n_categories,n_categories);
  Rcpp::NumericVector categorial_sizes(n_categories);

  Rcpp::NumericVector uncondioned_pattern_p(n_pattern);
  Rcpp::NumericMatrix condioned_pattern_p(n_pattern,n_categories);
  Rcpp::NumericMatrix expected_frequencies(n_pattern,n_categories);

  bool convergence;



  for(i=1;i<=random_starts;i++){

    aem=get_random_start_values_p(n_categories);
    categorial_sizes=get_random_start_values_class_sizes(n_categories);

    colnames(aem)=categorical_levels;
    rownames(aem)=categorical_levels;
    categorial_sizes.names()=categorical_levels;

    new_ll=fct_log_likelihood_c(categorial_sizes,
                                aem,
                                obs_pattern_shape,
                                obs_pattern_frq,
                                categorical_levels
                                  );
    rel_change=99.99;

    if(trace==true){
      Rcout << "Initial Log-Likelihood: " << new_ll << "\n";
    }


    iter=1;
    while(iter<=max_iterations && rel_change>rel_convergence){

      for(p=0;p<n_pattern;p++){
        pattern_p=0.0;
        for(c=0;c<n_categories;c++){
          index_c=c;
          tmp_p=1.0;
          for(r=0;r<n_rater;r++){
            string_pr=obs_pattern_shape(p,r);
            index_pr=categorial_sizes.findName(string_pr);
            tmp_p=tmp_p*aem(index_c,index_pr);
          }
          tmp_p=tmp_p*categorial_sizes(c);

          condioned_pattern_p(p,index_c)=tmp_p;

          pattern_p=pattern_p+tmp_p;
        }
        uncondioned_pattern_p(p)=pattern_p;
      }


      for(p=0;p<n_pattern;p++){
        for(c=0;c<n_categories;c++){
          expected_frequencies(p,c)=obs_pattern_frq(p)*
            condioned_pattern_p(p,c)/uncondioned_pattern_p(p);
        }
      }


      for(c=0;c<n_categories;c++){
        categorial_sizes(c)=Rcpp::sum(expected_frequencies(_,c));
      }
      categorial_sizes=categorial_sizes/N;

        for(c=0; c<n_categories;c++){
          for(a=0;a<n_categories;a++){
            tmp=0.0;
            for(p=0; p<n_pattern;p++){
              // Test
              tmp=tmp+expected_frequencies(p,c)*obs_internal_count(p,a);
            }

            aem(c,a)=tmp/(N*categorial_sizes(c));
          }
        }

        old_ll=new_ll;

          new_ll=fct_log_likelihood_c(categorial_sizes,
                                      aem,
                                      obs_pattern_shape,
                                      obs_pattern_frq,
                                      categorical_levels
                                      );

          rel_change=(old_ll-new_ll)/old_ll;

          if(trace==true){
            Rcout << "Start "<< i <<" Iteration " << iter <<" Log_Likelihood "
                  << new_ll << " relative change "<< rel_change << "\n";
          }

          iter=iter+1;
    }

    if(rel_change<=rel_convergence && iter<=max_iterations){
      convergence=true;
    } else {
      convergence=false;
    }


    Estimates_collection.push_back(Rcpp::List::create(Named("log_likelihood")=new_ll,
                                        Named("aem")=aem,
                                        Named("categorial_sizes")=categorial_sizes,
                                        Named("convergence")=convergence,
                                        Named("iteration")=iter-1)
                                     );

  }
  return Estimates_collection;
}

